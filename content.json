{"meta":{"title":"Yorhom's Lab","subtitle":"游戏开发，移动开发，Web开发","description":"游戏开发，移动开发，Web开发，HTML5，lufylegend，Yorhom，JavaScript，Python","author":"Yuehao","url":"http://yuehaowang.github.io"},"pages":[{"title":"关于我","date":"2017-07-16T10:53:08.000Z","updated":"2017-07-16T10:53:08.000Z","comments":true,"path":"about/index.html","permalink":"http://yuehaowang.github.io/about/index.html","excerpt":"","text":"简介在下Yorhom，编程爱好者。热忱于计算机科学与技术的研究，略懂JavaScript，Python，C/C++等程序语言。开发过数款HTML5跨平台游戏。 联系方式微博：@Yorhom邮箱：wangyuehao1999@gmail.comTwitter：@yuehaowangGithub：https://github.com/yuehaowang/ CSDN博客：http://blog.csdn.net/yorhomwangEnglish Homepage: http://wyh.wjjsoft.com 最后，欢迎各位交流～"},{"title":"分类","date":"2017-07-16T09:44:44.000Z","updated":"2016-02-04T17:19:50.000Z","comments":true,"path":"categories/index.html","permalink":"http://yuehaowang.github.io/categories/index.html","excerpt":"","text":""},{"title":"作品展示","date":"2017-07-28T07:08:04.000Z","updated":"2017-07-28T07:08:04.000Z","comments":true,"path":"showcase/index.html","permalink":"http://yuehaowang.github.io/showcase/index.html","excerpt":"","text":"以下是我业余时间做的一些小项目，欢迎各位参观～ 同时也欢迎大家到我的Github上去star或者fork其中的一些项目～ 开源库件Pylash 说明：Pylash是一款基于Python3和PyQt4的2D游戏引擎。模仿了flash中一些常用的类，如Sprite，Bitmap，TextField等。使用它，可以快速地编写Python游戏。 地址：Github项目地址 → Jpp 说明：Jpp是一个用于拓展JavaScript功能的库。通过Jpp，你可以构建含有public，private，protected属性/方法的类（ES6标准中已经可以用原生代码实现这一功能了）；重载函数（overload）；判定变量类型等。Jpp就是Js++的意思。 地址：Github项目地址 → 脚本语言Yaxi 说明：Yaxi /jəsi/ 是一款基于C++和Qt的简易脚本语言。Yaxi为你提供了定义变量，定义函数，循环，条件判断等句法，你可以通过yaxi十分轻松地写出有趣的小程序。同时，使用yaxi，你还可以进行简单算法的研究，让你熟悉程序设计的过程，感受程序设计的乐趣。 地址：Github项目地址 → 游戏Ink Spill 发布时间：2017年6月09日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：游戏开始后，在规定时间内通过点击界面最下方的颜色块，使方阵中的颜色块从左上角开始不断融合，所有颜色块融合成同一颜色后，游戏胜利。 地址：试玩地址 → Flying Stone 发布时间：2016年12月25日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：Flying Stone是一款益智类+物理运动模拟类游戏。游戏中，玩家通过轻敲屏幕，抛出系在旋转杆上的石头来攻击飞出的小鸟，以此得分。不同难度的小鸟，击中后得分也有所不同。游戏限时90秒，游戏结束后会上传你的得分，并得到你的全世界排行。 地址：游戏主页 → The Best Arithmetic 发布时间：2016年2月15日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：开始游戏后，点击两个数字，分别作为X和Y或者Y和X代入游戏下方的方程式，如果成立，则这两个数字就会抵消。抵消掉所有的数字后，当前关卡通过。你所消耗的时间将决定你的成绩。 地址：试玩地址 → Raglan and Over 发布时间：2015年7月22日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：游戏中，玩家需要操控小方块躲避迎面而来的红色三角形，同时可以吃一些道具或者使用“连步”来加分。本游戏使用了HTML5和lufylegend.js开源引擎。 地址：试玩地址 → Github项目地址 → 三国战线 发布时间：2015年5月31日 运行平台：Windows 说明：本游戏是一款另类塔防游戏。本作以三国这段历史为题材，提供了从颍川之战到官渡之战，官渡之战到夷陵之战，夷陵之战到五丈原之战等15个关卡。在每个关卡中，你会控制一名三国武将与出现的敌军进行交战以此保护你的主公；同时，你还可以召唤出你的友军，与你并肩作战。除此之外，本作还提供了人物对话，以及火计、水攻等计谋，使游戏可玩度更高。 地址：下载地址 → Github项目地址 → Greedy Bug 发布时间：2014年12月20日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：基于HTML5和lufylegend.js开源引擎的一款类似于贪吃蛇的游戏。相信这款游戏能给你带来欲速则不达、近在咫尺却无法触碰的虐心体验! 地址：试玩地址 → Github项目地址 → Crazy Racing 发布时间：2014年12月6日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：基于HTML5和lufylegend.js开源引擎的一款赛车游戏。游戏中，玩家需要通过操控赛车躲避前方的其他车辆。 地址：试玩地址 → Github项目地址 → 翻三国 发布时间：2013年2月13日 运行平台：IE9+，Google Chrome，Firefox，Opera，Safari，iOS，Android 说明：本游戏基于开源HTML5引擎lufylegend.js开发，是一款跨平台休闲类翻牌游戏。本游戏一共有五个关卡，随着关卡难度的增加会有更多卡牌出现。快来考验一下自己的记忆力吧～ 地址：试玩地址 → 如果以上作品存在bug，请及时联系我。"},{"title":"标签","date":"2017-07-16T09:44:44.000Z","updated":"2016-02-04T17:20:14.000Z","comments":true,"path":"tags/index.html","permalink":"http://yuehaowang.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"C++实现对数学基本运算表达式的解析","slug":"math_expression_parser","date":"2017-08-01T16:00:00.000Z","updated":"2017-08-02T09:36:24.000Z","comments":true,"path":"2017/08/02/math_expression_parser/","link":"","permalink":"http://yuehaowang.github.io/2017/08/02/math_expression_parser/","excerpt":"前段时间在LeetCode上刷题，遇到了很多涉及对字符串进行解析的题目。可能是出于这个原因，最近迷恋上了字符串的解析问题。数学基本运算表达式的解析就涉及这类问题。所谓数学基本运算表达式的解析就是指给定一个表达式字符串，如1 + 1，3 * 9，对这个字符串进行解析，从而得到这个表达式的运算结果。（数学基本运算表达式也就是只用加减乘除进行计算的数学表达式） 其实站在我的角度来看，我觉得对数学基本运算表达式的解析还是有一定难度的。因为如果一开始没有正确的思路，我们是很难找到这个问题的着手点的，毕竟解析数学基本运算表达式需要考虑到的问题是有点多的，以下，我把其中主要的问题列举出来： 乘除法优先计算 括号里的内容优先计算 表达式中的数字前可能存在正负号 这些问题如果得不到恰当的处理，就会使解析过程失败。 在实现解析数学基本运算表达式之前，我们首先得弄清楚哪些表达式是合法的，哪些表达式是不合法的。以下我将列举C/C++等语言中，一些合法与不合法的表达式： 123456789101112131415/* 合法 */7 + 22 + 7 * 276 + -13 * 23 / -30 / 3524 - +3410 + (3 * 9) / 8/* 不合法 */abc + 123 // abc不是数字1 + 2 * // *后缺少数字6 + + 12 // 不能连用加号8 - - 17 // 不能连用减号32 + () - 4 // 括号中没有内容(0 + 5)) * 7 // 右括号多了一个((11 + 9) / 2 // 左括号多了一个 不排除有一些编程语言支持上述所说的部分或者全部不合法表达式，但这里我们先使用C/C++标准。","text":"前段时间在LeetCode上刷题，遇到了很多涉及对字符串进行解析的题目。可能是出于这个原因，最近迷恋上了字符串的解析问题。数学基本运算表达式的解析就涉及这类问题。所谓数学基本运算表达式的解析就是指给定一个表达式字符串，如1 + 1，3 * 9，对这个字符串进行解析，从而得到这个表达式的运算结果。（数学基本运算表达式也就是只用加减乘除进行计算的数学表达式） 其实站在我的角度来看，我觉得对数学基本运算表达式的解析还是有一定难度的。因为如果一开始没有正确的思路，我们是很难找到这个问题的着手点的，毕竟解析数学基本运算表达式需要考虑到的问题是有点多的，以下，我把其中主要的问题列举出来： 乘除法优先计算 括号里的内容优先计算 表达式中的数字前可能存在正负号 这些问题如果得不到恰当的处理，就会使解析过程失败。 在实现解析数学基本运算表达式之前，我们首先得弄清楚哪些表达式是合法的，哪些表达式是不合法的。以下我将列举C/C++等语言中，一些合法与不合法的表达式： 123456789101112131415/* 合法 */7 + 22 + 7 * 276 + -13 * 23 / -30 / 3524 - +3410 + (3 * 9) / 8/* 不合法 */abc + 123 // abc不是数字1 + 2 * // *后缺少数字6 + + 12 // 不能连用加号8 - - 17 // 不能连用减号32 + () - 4 // 括号中没有内容(0 + 5)) * 7 // 右括号多了一个((11 + 9) / 2 // 左括号多了一个 不排除有一些编程语言支持上述所说的部分或者全部不合法表达式，但这里我们先使用C/C++标准。 原理讲解由于实现的过程很“绕圈子”，所以我就先把我的实现思路和原理告诉大家，供大家参考。后文会提供相关源代码下载。 （可能网上有大佬提供了更好、更高效的解析数学表达式方法，不过我认为我的处理方式是非常直白易懂的一种。） 首先，我们来回忆一下我们做数学计算时的情形： 第一步 如果数学运算表达式存在括号的话，我们会率先找到括号里的内容，并将括号里的内容当作一个新的数学表达式进行优先运算。将这个新的数学表达式进行运算后，用得到的结果将括号及括号间的内容替换掉。当我们把所有括号里的内容都用相应的结果替换掉后，就能得到原先数学表达式消去括号后的简化式子，然后我们再对这个式子进行处理。例如原有的数学式7 * (5 + 3)，进行消去括号的处理后，就得到了7 * 8，接下来我们再对这个式子进行解析和计算，就能得到答案。 第二步 消去括号的数学基本运算表达式就只剩加减乘除符号以及数字、小数点（如果有小数的话）了。由于乘法和除法要优先运算，如果式子中有这两种运算的话，我们就要率先在式子中进行乘法运算和除法运算。运算的过程中，我们采用的做法同样是把运算得到的结果替换掉原来的运算式子。如下计算过程示例可能会让你重拾这一过程： 12345677 + 18 * 5 / 9 | v7 + 90 / 9 | v7 + 10 第三步 进行完前两步的处理，剩下的式子就只有加减符号以及数字、小数点（如果有小数的话）了。用和第二步中类似的做法进行计算，最后，式子就化成了数字，这个数字就是我们的答案。以第二步示例中最后得到的式子为例，7 + 10运算得到17，17就是最后的答案。 现在，我们回忆完了平日里我们进行数学计算的步骤，其实这就是一个对表达式逐渐化简的过程。接下来我们就要从这些步骤中构思我们的解析算法。 在第一步中，我们提到了对括号里的内容进行优先计算。但是我们可能会遇到括号套括号的问题。但是正如第一步中所说，我们可以把括号里的式子当作新的一个式子来处理，对于新的式子又可以采用第一步到第三步的方式依次进行处理得到结果。这样一来就形成了一种递归关系。所以，我们只用实现如下几个接口，就能完成对数学基本运算式的解析： 接口A：处理运算式的统一接口 接口B：处理括号的接口 接口C：处理运算符的接口，一次可处理两种运算符号（因为四则运算符号可以分成 乘除一组，加减一组） 接口D：基本运算接口，即针对两个数字之间四则运算的接口 接口E：处理字符串的一个接口集合，提供了剔除字符串左右空白或者所有空白的接口、float与std::string相互转化的接口（为了方便小数计算，使用float类型） 第一步用接口B来完成，第二、三步用接口C来完成。接口C中使用接口D来进行结果运算，即接口C进行的操作是找到运算符并获取运算符两边的数字，然后交给接口D对这两个数字按照找到的运算符进行计算，再将得到的计算结果替换掉式子中相应的部分。而接口E为前几个接口提供辅助功能。 接口A是调用其他接口的一个入口。接口A~D的伪代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263float interface_A (const string&amp; exp)&#123; // 剔除表达式字符串的左右空白 string __exp = interface_E(exp); // 处理括号 interface_B(__exp); // 处理乘法除法运算 interface_C(__exp, pair&lt;string, string&gt;('*', '/')); // 处理加法减法运算 interface_C(__exp, pair&lt;string, string&gt;('+', '-')); // 将`std::string`转化为`float` float res = interface_E(__exp); // 返回结果 return res;&#125;void interface_B (string&amp; exp)&#123; for 遍历`exp` &#123; if 遇到括号 &#123; string content = 获取括号内容; // 将括号里的内容作为新的表达式处理 int val = interface_A(content); // 将`float`转化为`std::string` string valStr = interface_E(val); 将`exp`括号部分替换为valStr; 更新`exp`长度和遍历的下标位置; &#125; &#125;&#125;void interface_C (string&amp; exp, pair&lt;string, string&gt; operators)&#123; for 遍历`exp` &#123; if 遇到operators中的运算符 &#123; string strVal1 = 获取进行计算的数字1; string strVal2 = 获取进行计算的数字2; // 获取计算结果 float v = interface_D(strVal1, 运算符, strVal2); // 将`float`转化为`std::string` string valStr = interface_E(v); 将`exp`括号部分替换为valStr; 更新`exp`长度和遍历的下标位置; &#125; &#125;&#125;void interface_D (const string&amp; s1, const string&amp; _operator, const string&amp; s2)&#123; // 将`std::string`转化为`float` float n1 = interface_E(s1); float n2 = interface_E(s2); 根据运算符_operator进行n1 n2之间的计算;&#125; （至于接口E，由于是一个提供辅助功能的接口集，所以上面的伪代码中没有给出。具体实现方法请参考后文给出的源代码） 源代码下载上文仅提供了伪代码，也就是只有骨架还没有血肉。下面是我的实现代码，欢迎各位下载： 源代码下载当然，各位读者也可以根据我前面的原理讲解自行实现算法。 欢迎大家提出疑问以及探讨相关话题～","categories":[{"name":"C/C++","slug":"C-C","permalink":"http://yuehaowang.github.io/categories/C-C/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yuehaowang.github.io/tags/数学/"},{"name":"C/C++","slug":"C-C","permalink":"http://yuehaowang.github.io/tags/C-C/"}]},{"title":"NodeJs开发简易的Http本地服务器","slug":"simple_http_local_server_with_nodejs","date":"2017-07-09T16:00:00.000Z","updated":"2017-07-17T04:10:12.000Z","comments":true,"path":"2017/07/10/simple_http_local_server_with_nodejs/","link":"","permalink":"http://yuehaowang.github.io/2017/07/10/simple_http_local_server_with_nodejs/","excerpt":"第一次接触本地服务器是很早之前因为Js学到Ajax部分，需要通过发送Http请求读取本地文件。 网上实用的本地服务器有很多，如Apache，XAMPP等。不过在我平时开发的过程中，其实用不了太多功能，多数情况下只需要我们的服务器根据请求从本地读取文件，不大必要使用上述的大型本地服务器，所以在我接触NodeJs后，索性用NodeJs写了一个Http本地服务器，连同空行总共69行代码。 （成功开启服务器后的效果如上图所示）","text":"第一次接触本地服务器是很早之前因为Js学到Ajax部分，需要通过发送Http请求读取本地文件。 网上实用的本地服务器有很多，如Apache，XAMPP等。不过在我平时开发的过程中，其实用不了太多功能，多数情况下只需要我们的服务器根据请求从本地读取文件，不大必要使用上述的大型本地服务器，所以在我接触NodeJs后，索性用NodeJs写了一个Http本地服务器，连同空行总共69行代码。 （成功开启服务器后的效果如上图所示） 首先创建一个.js文件，文件名可以自定，这里我命名为fileServer.js。写入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869\"use strict\";var path = require(\"path\"), url = require(\"url\"), fs = require(\"fs\"), http = require(\"http\");var rootPath = path.resolve(process.argv[2] || \".\");var port = Number(process.argv[3]) || 8080;var server = http.createServer(function (request, response) &#123; var u = request.url, pathName = url.parse(u).pathname; console.log(\"\\n &gt;&gt;&gt; \" + request.method + \": \" + u + \" &lt;&lt;&lt; \\n\"); fileServer(pathName, response);&#125;);server.listen(port);function fileServer(pathName, response) &#123; var filePath = path.join(rootPath, pathName); readPath(filePath, response);&#125;function readPath (filePath, response) &#123; fs.stat(filePath, function (err, stats) &#123; if (!err) &#123; if (stats.isDirectory()) &#123; filePath = filePath + \"index.html\"; readPath(filePath, response); return; &#125; else if (!stats.isFile()) &#123; responseStatsChanged(false, filePath, response); return; &#125; responseStatsChanged(true, filePath, response); fs.createReadStream(filePath).pipe(response); return; &#125; responseStatsChanged(false, filePath, response); &#125;);&#125;function responseStatsChanged (stat, u, response) &#123; if (!stat) &#123; console.log(\"\\n &gt;&gt;&gt; 404 \" + u + \" &lt;&lt;&lt; \\n\"); response.writeHead(404); response.end(\"&lt;h1&gt;404 Not Found&lt;/h1&gt;\"); &#125; else &#123; console.log(\"\\n &gt;&gt;&gt; 200 \" + u + \" &lt;&lt;&lt; \\n\"); response.writeHead(200); &#125;&#125;console.log(\"\\n &gt;&gt;&gt; Server is running at http://127.0.0.1:\" + port + \"/ . &lt;&lt;&lt; \\n\"); 主要用了path，url，fs，http这几个模块。大致流程为： 获取命令行运行参数（一个目录地址，此后浏览器访问地址都是以此为根目录的，默认为fileServer.js所在目录） 利用http模块创建Http服务器 收到请求后，调用fileServer函数，通过path.join获取文件的绝对地址 调用readPath函数读取文件地址（如果地址所指是一个目录，那就读取目录下的index.html文件） 读取失败，response写入404；读取成功，response写入200，将读取的数据流入response 接下来，运行我们服务器（使用默认的fileServer.js所在目录为根目录）：1$ node ./fileServer.js 如果得到了与文首截图相似的输出效果，那说明服务器已经开启成功了。之后我们要测试我们的服务器。在我们创建的fileServer.js所在目录下创建一个index.html。写入代码： 12345678910&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Hello world!&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Hello World!&lt;/h1&gt;&lt;h2&gt;Test local server successfully!&lt;/h2&gt;&lt;/body&gt;&lt;/html&gt; 浏览器输入http://localhost:8080/index.html，然后进入网页，得到结果： 同时我们的终端也有输出： 可以看到，我们的本地服务器已经在正常地工作了。不过上面提供的代码很简陋，使用起来会有局限，例如：1, 直接输入目录名，如localhost:8080/dirname，将会得到404结果，必须输入localhost:8080/dirname/才能自动读取localhost:8080/dirname/index.html文件。2, 只提供404和200两种status，当然这个方面大家可以根据所需自行拓展～ 最后，如果是使用linux或者OS X的同学，可以把运行fileServer.js的命令写到一个shell文件里，然后放到usr/local/bin/下，这样一来，在运行我们的服务器时就不需要输入很长的命令了。","categories":[{"name":"HTML5&JavaScript","slug":"HTML5-JavaScript","permalink":"http://yuehaowang.github.io/categories/HTML5-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"},{"name":"NodeJs","slug":"NodeJs","permalink":"http://yuehaowang.github.io/tags/NodeJs/"}]},{"title":"【译】碰撞检测之分离轴定理算法讲解","slug":"sat-explanation","date":"2017-01-30T16:00:00.000Z","updated":"2017-02-04T16:24:24.000Z","comments":true,"path":"2017/01/31/sat-explanation/","link":"","permalink":"http://yuehaowang.github.io/2017/01/31/sat-explanation/","excerpt":"本文翻译自@sevenson的文章Separating Axis Theorem (SAT) Explanation 。原文作者用的是ActionScript 3来编写算法，不过文中主要讲述的还是算法原理，我想一旦算法原理被我们掌握了，选择什么编程语言来实现算法都是次要的事情了。本人并非英文专业，所以文中翻译得有不妥或疏漏之处，欢迎各位指正，谢谢！ 正文如下： 分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。 我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。 我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：）","text":"本文翻译自@sevenson的文章Separating Axis Theorem (SAT) Explanation 。原文作者用的是ActionScript 3来编写算法，不过文中主要讲述的还是算法原理，我想一旦算法原理被我们掌握了，选择什么编程语言来实现算法都是次要的事情了。本人并非英文专业，所以文中翻译得有不妥或疏漏之处，欢迎各位指正，谢谢！ 正文如下： 分离轴定理（英文简称SAT）是一项用于检测凸多边形碰撞的技术。 我绝不是这个方面的专家，但当检测碰撞的需求出现在我面前之后，我做了大量的阅读并最终在ActionScript 3中实现了它。 我想，我应该把我所学到的分享给大家，希望大家不会在这方面被坑得很惨：） 当我发现我需要在flash中检测多边形碰撞时，我碰巧地遇到了一个叫“分离轴定理”的方法。但唯一的问题是，为了真正地掌握它，我可费了不少功夫。 在阅读了大量有关碰撞检测的资料，并参看了一些代码示例后，这个方法总算被我领悟了。 为了帮助其他那些不精通数学的开发者，我想我应该写下这一篇能快速阐明这个算法工作原理的简短介绍。我还在下文引入了一个使用分离轴定理实现的demo，以及供大家下载并使用的ActionScript 3源代码。（译者：demo和源代码请到原文中查看和下载） 注意：分离轴定理需要一点数学向量的知识，所以在深究这个算法前，你最好复习一下这方面的内容。 算法简述从根本上来讲，分离轴定理（以及其他碰撞算法）的用途就是去检测并判断两个图形之间是否有间隙。分离轴定理中用到的方法使算法本身显得十分独特。 我所听到过分离轴定理的最好类比方式是这样的： 假想你拿一个电筒从不同的角度照射到两个图形上，那么会有怎样的一系列的阴影投射到它们之后的墙壁上呢？ 如果你用这个方式从每一个角度上对这两个图形进行处理，并都找不到任何的间隙，那么这两个图形就一定接触。如果你找到了一个间隙，那么这两个图形就显而易见地没有接触。 从编程的角度来讲，从每个可能的角度上去检测会使处理变得十分密集。不过幸运的是，由于多边形的性质，你只需要检测其中几个关键的角度。 你需要检测的角度数量就正是这个多边形的边数。也就是说，你所需检测的角度最大数量就是你要检测碰撞的两个多边形边数之和。举个例子，两个五边形就需要检测10个角度。 如何在代码中实现这是一个简易但比较啰嗦的方法，以下是基本的步骤： 步骤一：从需要检测的多边形中取出一条边，并找出它的法向量（垂直于它的向量），这个向量将会是我们的一个“投影轴”。 步骤二：循环获取第一个多边形的每个点，并将它们投影到这个轴上。（记录这个多边形投影到轴上的最高和最低点） 步骤三：对第二个多边形做同样的处理。 步骤四：分别得到这两个多边形的投影，并检测这两段投影是否重叠。 如果你发现了这两个投影到轴上的“阴影”有间隙，那么这两个图形一定没有相交。但如果没有间隙，那么它们则可能接触，你需要继续检测直到把两个多边形的每条边都检测完。如果你检测完每条边后，都没有发现任何间隙，那么它们是相互碰撞的。 这个算法基本就是如此的。 顺带提一下，如果你记录了哪个轴上的投影重叠值最小（以及重叠了多少），那么你就能用这个值来分开这两个图形。 那么如何处理圆呢？在分离轴定理中，检测圆与检测多边形相比，会有点点奇异，但仍然是可以实现的。 最值得注意的是，圆是没有任何的边，所以是没有明显的用于投影的轴。但它有一条“不是很明显的”的投影轴。这条轴就是途经圆心和多边形上离圆心最近的顶点的直线。 在这以后就是按套路遍历另一个多边形的每条投影轴，并检测是否有投影重叠。 噢，对了，万一你想知道如何把圆投影到轴上，那你只用简单地把圆心投影上去，然后加上和减去半径就能得到投影长度了。 优点与不足和其他的碰撞检测技术一样，分离轴定理算法有它自己的优点和不足。以下是其一些优点和不足的简要概述： 优点（译者：原来老外也喜欢先谈优点啊～&gt;～） 分离轴定理算法十分得快——它完美地使用了基本的数学向量知识。只要间隙一旦被检测出来，那么你就能马上得出结果，消除不必要的运算。 分离轴定理算法十分得准——至少据我所知是这样的。（译者：突然感觉作者好不靠谱啊，囧……） 不足 分离轴定理算法只适用于凸多边形——复杂的图形（译者：指的是凹多边形，比如五角星）无法使用此方法，除非你把它们分成一些小的凸多边形，然后依次检验这些小的多边形。 分离轴定理算法无法告诉你是那条边发生的碰撞——仅仅是告诉你重叠了多少和分开它们所需的最短距离。 可能这个算法会有更多优点和不足之处，但是我想这应该是最主要的几个了。 总结我希望这篇文章能帮助你了解到分离轴定理算法。我已经尽可能地不提供过多的信息并讲解得十分简明了。（我绝不是数学方面的专家，所以如果我遗漏了什么，我深表歉意） 以下是一些帮助我理解分离轴定理算法的页面： harverycartel.org——有更多详细的表述以及很多很酷的示例。我在这个页面上学到了很多。 GPWiki.org——有不错的讲解和代码示例，我用这些代码作为编写自己代码的基础。 Tony Pa——向量教程，学习向量的不错资源。 GameDev.net forum——一个论坛成员写的分离轴定理碰撞检测系统，带给了我一些计算方面的想法。 以下是译者补充的内容 我将文中的算法用JavaScript实现了一遍，大家有兴趣的话，可以到下面提供的链接中下载源代码或查看在线demo。 源代码下载查看在线Demo","categories":[{"name":"译文","slug":"译文","permalink":"http://yuehaowang.github.io/categories/译文/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yuehaowang.github.io/tags/数学/"},{"name":"算法","slug":"算法","permalink":"http://yuehaowang.github.io/tags/算法/"},{"name":"译文","slug":"译文","permalink":"http://yuehaowang.github.io/tags/译文/"}]},{"title":"分享新作 - 虐心小游戏Flying Stone","slug":"new-game-flying-stone","date":"2016-12-24T16:00:00.000Z","updated":"2017-07-16T10:28:43.000Z","comments":true,"path":"2016/12/25/new-game-flying-stone/","link":"","permalink":"http://yuehaowang.github.io/2016/12/25/new-game-flying-stone/","excerpt":"游戏简介Flying Stone是一款益智类物理游戏。游戏中，玩家通过轻敲屏幕，抛出系在旋转杆上的石头来攻击飞出的小鸟，以此得分。不同难度的小鸟，击中后得分也有所不同。游戏限时90秒，游戏结束后会上传你的得分，并得到你的全世界排行。 本游戏目前支持Android版和在线版。 如何开始访问游戏主页，你可以在其中找到所需的版本： http://wyh.wjjsoft.com/pages/flying_stone/","text":"游戏简介Flying Stone是一款益智类物理游戏。游戏中，玩家通过轻敲屏幕，抛出系在旋转杆上的石头来攻击飞出的小鸟，以此得分。不同难度的小鸟，击中后得分也有所不同。游戏限时90秒，游戏结束后会上传你的得分，并得到你的全世界排行。 本游戏目前支持Android版和在线版。 如何开始访问游戏主页，你可以在其中找到所需的版本： http://wyh.wjjsoft.com/pages/flying_stone/ 手机用户可以通过扫描以下二维码访问游戏主页。 游戏截图以下是本游戏的游戏截图，敬请欣赏： 制作后记开发这款游戏，足足花了我将近2.5个月的时间，这2.5个月并不是整整的2.5个月，毕竟在下平时要上学，只能利用周六和周日晚上将近4个小时的开发。各位可别小看这一款游戏，用到的技术可是从前端的HTML5到移动端Android再到后端的CGI，而且这一切都由在下一人完成，所以开发这样的小游戏耗不少时间。不过好在开发过程中，我又学到了或者复习了不少技术，比如第一次从事Java Android开发，重拾C++，接触CGI编程等……可见收获不小。此外，我还要感谢伟大的互联网，她为我提供了大量的游戏素材和丰富的学习资源，与此同时我也要向免费提供素材的网友以及开源库件的开发者们表示衷心的感谢。 如果游戏异常，请及时联系我，谢谢～","categories":[{"name":"App发布","slug":"App发布","permalink":"http://yuehaowang.github.io/categories/App发布/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yuehaowang.github.io/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://yuehaowang.github.io/tags/canvas/"},{"name":"lufylegend","slug":"lufylegend","permalink":"http://yuehaowang.github.io/tags/lufylegend/"},{"name":"App","slug":"App","permalink":"http://yuehaowang.github.io/tags/App/"},{"name":"Android","slug":"Android","permalink":"http://yuehaowang.github.io/tags/Android/"}]},{"title":"挑战速度，2小时完成HTML5拼图小游戏","slug":"develop-puzzle-within-2h","date":"2016-08-08T16:00:00.000Z","updated":"2017-08-02T09:35:01.000Z","comments":true,"path":"2016/08/09/develop-puzzle-within-2h/","link":"","permalink":"http://yuehaowang.github.io/2016/08/09/develop-puzzle-within-2h/","excerpt":"初学lufylegend.js之日，我用lufylegend.js开发了第一个HTML5小游戏——拼图游戏，还写了篇博文来炫耀一下：HTML5小游戏《智力大拼图》发布，挑战你的思维风暴。不过当时初学游戏开发，经验浅薄，所以没有好好专研游戏里的算法和代码的缺陷，导致游戏出现了很多bug，甚至拼图打乱后很可能无法复原。最近经常有朋友问起这个游戏，希望我能把代码里的bug改一下方便初学者学习，顺便我也打算测试一下自己写这种小游戏的速度，所以就抽出了一些时间将这个游戏从头到尾重新写了一遍，计算了一下用时，从准备、修改素材到最后完成游戏，一共用了大约2h的时间。 以下是游戏地址： http://yuehaowang.github.io/games/puzzle/ 这是我的游戏记录，欢迎各位挑战： 接下来就来讲讲如何开发完成这款游戏的。（按“编年体”）","text":"初学lufylegend.js之日，我用lufylegend.js开发了第一个HTML5小游戏——拼图游戏，还写了篇博文来炫耀一下：HTML5小游戏《智力大拼图》发布，挑战你的思维风暴。不过当时初学游戏开发，经验浅薄，所以没有好好专研游戏里的算法和代码的缺陷，导致游戏出现了很多bug，甚至拼图打乱后很可能无法复原。最近经常有朋友问起这个游戏，希望我能把代码里的bug改一下方便初学者学习，顺便我也打算测试一下自己写这种小游戏的速度，所以就抽出了一些时间将这个游戏从头到尾重新写了一遍，计算了一下用时，从准备、修改素材到最后完成游戏，一共用了大约2h的时间。 以下是游戏地址： http://yuehaowang.github.io/games/puzzle/ 这是我的游戏记录，欢迎各位挑战： 接下来就来讲讲如何开发完成这款游戏的。（按“编年体”） 准备阶段准备lufylegend游戏引擎，大家可以去官方网站下载： lufylegend.com/lufylegend 引擎文档地址： lufylegend.com/lufylegend/api 可以说，如果没有强大的lufylegend引擎，这种html5小游戏用原生canvas制作，少说要一天呢。 0～30min准备素材（10min） + 修改素材（20min）。由于在下实在手残，不善于P图，修改图片用了大约20min，囧…… 30～50min开发开始界面。游戏不能没有开始界面所以我们首先实现这部分代码。在此之前是index.html里的代码，代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Puzzle&lt;/title&gt; &lt;meta charset=\"utf-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0,user-scalable=no\"&gt; &lt;script type=\"text/javascript\" src=\"./lib/lufylegend-1.10.1.simple.min.js\"&gt;&lt;/script&gt; &lt;script type=\"text/javascript\" src=\"./js/Main.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body style=\"margin: 0px; font-size: 0px; background: #F2F2F2;\"&gt; &lt;div id=\"mygame\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 主要是引入一些js文件，不多说。然后准备一个Main.js文件，在这个文件里添加初始化界面和加载资源的代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566/** 初始化游戏 */LInit(60, \"mygame\", 390, 580, main);var imgBmpd;/** 游戏层 */var stageLayer, gameLayer, overLayer;/** 拼图块列表 */var blockList;/** 是否游戏结束 */var isGameOver;/** 用时 */var startTime, time, timeTxt;/** 步数 */var steps, stepsTxt;function main () &#123; /** 全屏设置 */ if (LGlobal.mobile) &#123; LGlobal.stageScale = LStageScaleMode.SHOW_ALL; &#125; LGlobal.screen(LGlobal.FULL_SCREEN); /** 添加加载提示 */ var loadingHint = new LTextField(); loadingHint.text = \"资源加载中……\"; loadingHint.size = 20; loadingHint.x = (LGlobal.width - loadingHint.getWidth()) / 2; loadingHint.y = (LGlobal.height - loadingHint.getHeight()) / 2; addChild(loadingHint); /** 加载图片 */ LLoadManage.load( [ &#123;path : \"./js/Block.js\"&#125;, &#123;name : \"img\", path : \"./images/img.jpg\"&#125; ], null, function (result) &#123; /** 移除加载提示 */ loadingHint.remove(); /** 保存位图数据，方便后续使用 */ imgBmpd = new LBitmapData(result[\"img\"]); gameInit(); &#125; );&#125;function gameInit (e) &#123; /** 初始化舞台层 */ stageLayer = new LSprite(); stageLayer.graphics.drawRect(0, \"\", [0, 0, LGlobal.width, LGlobal.height], true, \"#EFEFEF\"); addChild(stageLayer); /** 初始化游戏层 */ gameLayer = new LSprite(); stageLayer.addChild(gameLayer); /** 初始化最上层 */ overLayer = new LSprite(); stageLayer.addChild(overLayer); /** 添加开始界面 */ addBeginningUI();&#125; 以上代码有详细注释，大家可以对照引擎文档和注释进行阅读。有些全局变量会在以后的代码中使用，大家可以先忽略。接下来是addBeginningUI函数里的代码，用于实现开始界面： 123456789101112131415161718192021222324252627282930313233function addBeginningUI () &#123; var beginningLayer = new LSprite(); beginningLayer.graphics.drawRect(0, \"\", [0, 0, LGlobal.width, LGlobal.height], true, \"#EDEDED\"); stageLayer.addChild(beginningLayer); /** 游戏标题 */ var title = new LTextField(); title.text = \"拼图游戏\"; title.size = 50; title.weight = \"bold\"; title.x = (LGlobal.width - title.getWidth()) / 2; title.y = 160; title.color = \"#FFFFFF\"; title.lineWidth = 5; title.lineColor = \"#000000\"; title.stroke = true; beginningLayer.addChild(title); /** 开始游戏提示 */ var hint = new LTextField(); hint.text = \"- 点击屏幕开始游戏 -\"; hint.size = 25; hint.x = (LGlobal.width - hint.getWidth()) / 2; hint.y = 370; beginningLayer.addChild(hint); /** 开始游戏 */ beginningLayer.addEventListener(LMouseEvent.MOUSE_UP, function () &#123; beginningLayer.remove(); startGame(); &#125;);&#125; 到此，运行代码，得到我们的开始界面： 看到这个画面，其实我自己都想吐槽一下实在是太“朴素”了，囧…… 不过我这次图个制作速度，所以还望各位看官海量。 50～90min这40分钟的时间，是最关键时期，期间我们要完成整个游戏的主体部分。首先，我们需要用代码来实现以下过程： 12345初始化游戏界面数据（如游戏时间、所用步数）和显示一些UI部件（如图样）|-&gt; 获取随机的拼图块位置|-&gt; 显示打乱后的拼图块 我们将这些步骤做成一个个的函数方便我们统一调用： 12345678910111213141516171819202122function startGame () &#123; isGameOver = false; /** 初始化时间和步数 */ startTime = (new Date()).getTime(); time = 0; steps = 0; /** 初始化拼图块列表 */ initBlockList(); /** 打乱拼图 */ getRandomBlockList(); /** 显示拼图 */ showBlock(); /** 显示缩略图 */ showThumbnail(); /** 显示时间 */ addTimeTxt(); /** 显示步数 */ addStepsTxt(); stageLayer.addEventListener(LEvent.ENTER_FRAME, onFrame);&#125; 函数一开始，我们把isGameOver变量设定为false代表游戏未结束，在后期的代码里，我们会看到这个变量的作用。接着我们初始化了用于表示时间和步数的time和steps这两个全局变量，另外初始化变量startTime的值用于后面计算游戏时间。接下来，我们就要开始初始化拼图块了。见initBlockList里的代码： 12345678910function initBlockList () &#123; blockList = new Array(); for (var i = 0; i &lt; 9; i++) &#123; /** 根据序号计算拼图块图片显示位置 */ var y = (i / 3) &gt;&gt;&gt; 0, x = i % 3; blockList.push(new Block(i, x, y)); &#125;&#125; 这里我们使用了一个Block类，这个类用于显示拼图块和储存拼图块的数据，并提供了一些方法来操控拼图块，下面是其构造器的代码： 12345678910111213141516function Block (index, x, y) &#123; LExtends(this, LSprite, []); var bmpd = imgBmpd.clone(); bmpd.setProperties(x * 130, y * 130, 130, 130); this.bmp = new LBitmap(bmpd); this.addChild(this.bmp); var border = new LShape(); border.graphics.drawRect(3, \"#CCCCCC\", [0, 0, 130, 130]); this.addChild(border); this.index = index; this.addEventListener(LMouseEvent.MOUSE_UP, this.onClick);&#125; Block类继承自LSprite，属于一个显示对象，所以我们在这个类中添加了一个位图对象用于显示拼图块对应的图片。除此之外，我们还为拼图块添加了一个边框，在显示时用于隔开周围的拼图块。Block类有一个index属性，代表拼图块在拼图块列表blockList中的正确位置。最后，我们为此类添加了一个鼠标按下事件，用于处理鼠标按下后移动图块操作。 接下来我们还要介绍这个类的一个方法setLocation： 1234567Block.prototype.setLocation = function (x, y) &#123; this.locationX = x; this.locationY = y; this.x = x * 130; this.y = y * 130;&#125;; 这个方法用于设置拼图块对象的显示位置以及保存拼图块的“数组位置”。什么是“数组位置”呢？各位看官可以通过下面的图片加以了解： 可以看到，“数组位置”就类似于二维数组中的元素下标。储存这个位置的作用在于可以很方便地从blockList中获取到附近的其他拼图块。这个方法在我们显示拼图时有调用到，在显示拼图之前，我们得先打乱拼图，见如下代码： 123456789101112131415161718192021222324252627function getRandomBlockList () &#123; /** 随机打乱拼图 */ blockList.sort(function () &#123; return 0.5 - Math.random(); &#125;); /** 计算逆序和 */ var reverseAmount = 0; for (var i = 0, l = blockList.length; i &lt; l; i++) &#123; var currentBlock = blockList[i]; for (var j = i + 1; j &lt; l; j++) &#123; var comparedBlock = blockList[j]; if (comparedBlock.index &lt; currentBlock.index) &#123; reverseAmount++; &#125; &#125; &#125; /** 检测打乱后是否可还原 */ if (reverseAmount % 2 != 0) &#123; /** 不合格，重新打乱 */ getRandomBlockList(); &#125;&#125; 打乱拼图部分直接用数组的sort方法进行随机打乱： 123blockList.sort(function () &#123; return 0.5 - Math.random();&#125;); 其实打乱算法有很多种，我这里采用最粗暴的方法，也就是随机打乱。这种算法简单是简单，坏在可能出现无法复原的现象。针对这个问题，就有配套的检测打乱后是否可还原的算法，具体的算法理论我借用lufy大神的评论： 此类游戏能否还原关键是看它打乱后的逆序次数之和是否为偶数假设你打乱后的数组中的每一个小图块为obj0，obj1，obj2，…它们打乱之前的序号分别为obj0.num，obj1.num…接下来循环数组，如果前面元素的序号比此元素后某个元素的序号大，如obj0.num &gt; obj1.num或者obj2.num &gt; obj4.num就表示一个逆序当全部的逆序之和为奇数时表示不可还原，重新打乱即可，打乱后重新检测，直到逆序之和为偶数为止 举个例子，如果有一个数组为[3, 4, 2, 1]，那么里面3 2, 3 1, 4 2, 4 1, 2 1是逆序的，所以逆序数是5。 上面我给出的getRandomBlockList里的代码就是在实现打乱算法和检测是否可还原算法。 还有一种打乱方式，大家可以尝试尝试：和复原拼图一样，将空白块一步一步地与周围的拼图随机交换顺序。这个打乱算法较上一种而言，不会出现无法复原的现象，而且可以根据打乱的步数设定游戏难度。 在完成打乱拼图块后，如期而至的是显示拼图块： 123456789101112function showBlock() &#123; for (var i = 0, l = blockList.length; i &lt; l; i++) &#123; var b = blockList[i]; /** 根据序号计算拼图块位置 */ var y = (i / 3) &gt;&gt;&gt; 0, x = i % 3; b.setLocation(x, y); gameLayer.addChild(b); &#125;&#125; 显示了拼图块后，我们要做的就是添加操作拼图块的功能。于是需要拓展Block类，为其添加事件监听器onClick方法： 12345678910111213141516171819202122232425262728293031323334353637383940414243Block.prototype.onClick = function (e) &#123; var self = e.currentTarget; if (isGameOver) &#123; return; &#125; var checkList = new Array(); /** 判断右侧是否有方块 */ if (self.locationX &gt; 0) &#123; checkList.push(Block.getBlock(self.locationX - 1, self.locationY)); &#125; /** 判断左侧是否有方块 */ if (self.locationX &lt; 2) &#123; checkList.push(Block.getBlock(self.locationX + 1, self.locationY)); &#125; /** 判断上方是否有方块 */ if (self.locationY &gt; 0) &#123; checkList.push(Block.getBlock(self.locationX, self.locationY - 1)); &#125; /** 判断下方是否有方块 */ if (self.locationY &lt; 2) &#123; checkList.push(Block.getBlock(self.locationX, self.locationY + 1)); &#125; for (var i = 0, l = checkList.length; i &lt; l; i++) &#123; var checkO = checkList[i]; /** 判断是否是空白拼图块 */ if (checkO.index == 8) &#123; steps++; updateStepsTxt(); Block.exchangePosition(self, checkO); break; &#125; &#125;&#125;; 首先，我们在这里看到了isGameOver全局变量的作用，即在游戏结束后，阻断点击拼图块后的操作。 在点击了拼图块后，我们先获取该拼图块周围的拼图块，并将它们装入checkList，再遍历checkList，当判断到周围有空白拼图块后，即周围有index属性等于8的拼图块后，先更新操作步数，然后将这两个拼图块交换位置。具体交换拼图块位置的方法详见如下代码： 1234567891011121314151617Block.exchangePosition = function (b1, b2) &#123; var b1x = b1.locationX, b1y = b1.locationY, b2x = b2.locationX, b2y = b2.locationY, b1Index = b1y * 3 + b1x, b2Index = b2y * 3 + b2x; /** 在地图块数组中交换两者位置 */ blockList.splice(b1Index, 1, b2); blockList.splice(b2Index, 1, b1); /** 交换两者显示位置 */ b1.setLocation(b2x, b2y); b2.setLocation(b1x, b1y); /** 判断游戏是否结束 */ Block.isGameOver();&#125;; 还有就是Block.getBlock静态方法，用于获取给定的“数组位置”下的拼图块： 123Block.getBlock = function (x, y) &#123; return blockList[y * 3 + x];&#125;; 在Block.exchangePosition中，我们通过Block.isGameOver判断玩家是否已将拼图复原： 123456789101112131415161718Block.isGameOver = function () &#123; var reductionAmount = 0, l = blockList.length; /** 计算还原度 */ for (var i = 0; i &lt; l; i++) &#123; var b = blockList[i]; if (b.index == i) &#123; reductionAmount++; &#125; &#125; /** 计算是否完全还原 */ if (reductionAmount == l) &#123; /** 游戏结束 */ gameOver(); &#125; &#125;; 到这里，我们就实现了打乱和操作拼图块部分。 90～120min最后30min用于细枝末节上的处理，如显示拼图缩略图、显示&amp;更新时间和步数，以及添加游戏结束画面，这些就交给如下冗长而简单的代码来完成吧： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137function showThumbnail() &#123; var thumbnail = new LBitmap(imgBmpd); thumbnail.scaleX = 130 / imgBmpd.width; thumbnail.scaleY = 130 / imgBmpd.height; thumbnail.x = (LGlobal.width - 100) /2; thumbnail.y = 410; overLayer.addChild(thumbnail);&#125;function addTimeTxt () &#123; timeTxt = new LTextField(); timeTxt.stroke = true; timeTxt.lineWidth = 3; timeTxt.lineColor = \"#54D9EF\"; timeTxt.color = \"#FFFFFF\"; timeTxt.size = 18; timeTxt.x = 20; timeTxt.y = 450; overLayer.addChild(timeTxt); updateTimeTxt();&#125;function updateTimeTxt () &#123; timeTxt.text = \"时间：\" + getTimeTxt(time);&#125;function getTimeTxt () &#123; var d = new Date(time); return d.getMinutes() + \" : \" + d.getSeconds();&#125;;function addStepsTxt () &#123; stepsTxt = new LTextField(); stepsTxt.stroke = true; stepsTxt.lineWidth = 3; stepsTxt.lineColor = \"#54D9EF\"; stepsTxt.color = \"#FFFFFF\"; stepsTxt.size = 18; stepsTxt.y = 450; overLayer.addChild(stepsTxt); updateStepsTxt();&#125;function updateStepsTxt () &#123; stepsTxt.text = \"步数：\" + steps; stepsTxt.x = LGlobal.width - stepsTxt.getWidth() - 20;&#125;function onFrame () &#123; if (isGameOver) &#123; return; &#125; /** 获取当前时间 */ var currentTime = (new Date()).getTime(); /** 计算使用的时间并更新时间显示 */ time = currentTime - startTime; updateTimeTxt();&#125;function gameOver () &#123; isGameOver = true; var resultLayer = new LSprite(); resultLayer.filters = [new LDropShadowFilter()]; resultLayer.graphics.drawRoundRect(3, \"#BBBBBB\", [0, 0, 350, 350, 5], true,\"#DDDDDD\"); resultLayer.x = (LGlobal.width - resultLayer.getWidth()) / 2; resultLayer.y = LGlobal.height / 2; resultLayer.alpha = 0; overLayer.addChild(resultLayer); var title = new LTextField(); title.text = \"游戏通关\" title.weight = \"bold\"; title.stroke = true; title.lineWidth = 3; title.lineColor = \"#555555\"; title.size = 30; title.color = \"#FFFFFF\"; title.x = (resultLayer.getWidth() - title.getWidth()) / 2; title.y = 30; resultLayer.addChild(title); var usedTimeTxt = new LTextField(); usedTimeTxt.text = \"游戏用时：\" + getTimeTxt(time); usedTimeTxt.size = 20; usedTimeTxt.stroke = true; usedTimeTxt.lineWidth = 2; usedTimeTxt.lineColor = \"#555555\"; usedTimeTxt.color = \"#FFFFFF\"; usedTimeTxt.x = (resultLayer.getWidth() - usedTimeTxt.getWidth()) / 2; usedTimeTxt.y = 130; resultLayer.addChild(usedTimeTxt); var usedStepsTxt = new LTextField(); usedStepsTxt.text = \"所用步数：\" + steps; usedStepsTxt.size = 20; usedStepsTxt.stroke = true; usedStepsTxt.lineWidth = 2; usedStepsTxt.lineColor = \"#555555\"; usedStepsTxt.color = \"#FFFFFF\"; usedStepsTxt.x = usedTimeTxt.x; usedStepsTxt.y = 180; resultLayer.addChild(usedStepsTxt); var hintTxt = new LTextField(); hintTxt.text = \"- 点击屏幕重新开始 -\"; hintTxt.size = 23; hintTxt.stroke = true; hintTxt.lineWidth = 2; hintTxt.lineColor = \"#888888\"; hintTxt.color = \"#FFFFFF\"; hintTxt.x = (resultLayer.getWidth() - hintTxt.getWidth()) / 2; hintTxt.y = 260; resultLayer.addChild(hintTxt); LTweenLite.to(resultLayer, 0.5, &#123; alpha : 0.7, y : (LGlobal.height - resultLayer.getHeight()) / 2, onComplete : function () &#123; /** 点击界面重新开始游戏 */ stageLayer.addEventListener(LMouseEvent.MOUSE_UP, function () &#123; gameLayer.removeAllChild(); overLayer.removeAllChild(); stageLayer.removeAllEventListener(); startGame(); &#125;); &#125; &#125;);&#125; Ok，2h下来，整个游戏就搞定咯～不得不表扬一下lufylegend这个游戏引擎，实在是可以大幅提升开发效率。 源代码下载最后奉上源代码： 点击下载致谢与反思这篇博文在最初写成的时候，我没有对逆序算法进行深入研究，再加上我的测试不仔细，我没有发现算法的错误之处。因此，在博文发布后，不少读者发现游戏无解现象并将此问题反馈给了我，经过网友热心帮助，我才找到了问题所在，并更正了算法。在此对这些热心的网友表示真心的感谢，也为我学习不深入，以及误导了不少读者而感到十分内疚自责。 如果大家对本文有任何意见或不解，欢迎留言～","categories":[{"name":"HTML5&JavaScript","slug":"HTML5-JavaScript","permalink":"http://yuehaowang.github.io/categories/HTML5-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yuehaowang.github.io/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://yuehaowang.github.io/tags/canvas/"},{"name":"lufylegend","slug":"lufylegend","permalink":"http://yuehaowang.github.io/tags/lufylegend/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yuehaowang.github.io/tags/游戏开发/"}]},{"title":"算法研究：利用Python解决数学计数原理问题","slug":"counting-principle-algorithm","date":"2016-07-21T16:00:00.000Z","updated":"2017-02-01T14:41:40.000Z","comments":true,"path":"2016/07/22/counting-principle-algorithm/","link":"","permalink":"http://yuehaowang.github.io/2016/07/22/counting-principle-algorithm/","excerpt":"最近数学修行到“计数原理”部分，前几天做作业时遇到这样一道数学题： 用四种不同颜色给三棱柱六个顶点涂色,要求每个点涂一种颜色,且每条棱的两个端点涂不同颜色,则不同的涂色方法有多少种？ 当我看完题目后，顿时不知所措。于是我拿起草稿纸在一旁漫无目的地演算了一下，企图能找到解决方法。结果一无所获。今天终于等到放假了，于是打算通过程序算法解决这个问题。经过2个多小时的研究，终于完成了代码，并求得了答案。 由于Python写起来比较方便而且本人比较喜欢Python的语法，所以研究算法时我通常采用Python，此次也不例外。以下就是整个算法的实现过程。","text":"最近数学修行到“计数原理”部分，前几天做作业时遇到这样一道数学题： 用四种不同颜色给三棱柱六个顶点涂色,要求每个点涂一种颜色,且每条棱的两个端点涂不同颜色,则不同的涂色方法有多少种？ 当我看完题目后，顿时不知所措。于是我拿起草稿纸在一旁漫无目的地演算了一下，企图能找到解决方法。结果一无所获。今天终于等到放假了，于是打算通过程序算法解决这个问题。经过2个多小时的研究，终于完成了代码，并求得了答案。 由于Python写起来比较方便而且本人比较喜欢Python的语法，所以研究算法时我通常采用Python，此次也不例外。以下就是整个算法的实现过程。 两种算法我一共想出了两种用于解决本题的算法： 算法一：将所有的涂色情况通过程序的循环计算出来，然后通过程序的条件判断去除掉不合题意的所有情况，最后得到最终结果。 算法二：从其中任意一个端点（p0）入手，由于其它所有端点都没有涂色，所以它可以涂四种颜色。将这四种颜色通过循环分别涂在这个端点上，每涂上一种颜色后，获取与它相临的一个端点（p1），并获取它可以涂上的颜色，然后通过循环将可用颜色涂上（及不能涂上与p0相同的颜色），每涂上一种颜色，又将p1相邻的未涂色的点涂色（及除p0外其他的相邻端点）。每个点被涂色后都采用同样的方法将相邻的点涂色，以此类推，涂完最后一个点，就记一次情况。所有的递归都完成后，就获得了所有情况。 算法一很直接很粗暴，所以我采用了算法二来解决上述问题。接下来就是具体的代码了。 算法实现我写了大约90行Python代码来实现这个算法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687colorList = [0, 1, 2, 3]pointList = []amount = 0class Point(object): def __init__(self): super(Point, self).__init__() self.neibors = [] self.color = None def paint(self, c): self.color = c def clean(self): self.color = None def getLeftOverColors(self): copyOfColorList = colorList[0 : 4] for neibor in self.neibors: nc = neibor.color if nc in copyOfColorList: copyOfColorList.remove(nc) return copyOfColorListdef main(): global pointList p0 = Point() p1 = Point() p2 = Point() p3 = Point() p4 = Point() p5 = Point() p0.neibors = [p1, p2, p4] p1.neibors = [p0, p2, p5] p2.neibors = [p0, p1, p3] p3.neibors = [p2, p4, p5] p4.neibors = [p0, p3, p5] p5.neibors = [p4, p3, p1] pointList = [p0, p1, p2, p3, p4, p5] paintPoint(p0) print(amount)def paintPoint(p): global amount colors = p.getLeftOverColors() lastOne = isLastOne() for c in colors: p.paint(c) if lastOne: amount += 1 else: for currentNeibor in p.neibors: if currentNeibor.color == None: paintPoint(currentNeibor) break p.clean()def isLastOne(): global pointList paintedNum = 0 for p in pointList: if p.color != None: paintedNum += 1 return paintedNum == 5if __name__ == \"__main__\": main() 以下是对各段代码的介绍。 全局变量 colorList：颜色列表 pointList：存放六个点的列表 amount : 涂色方案的种数 Point类用于储存各个点的信息，如点的颜色（color属性，None代表无颜色）、相邻的点（’neibors’属性）。以及提供paint方法用于将点标记颜色；clean方法用于去除颜色；getLeftOverColors方法用于获取可用颜色，及获取相邻点没有使用的颜色。 main函数程序开始运行时调用的函数，其中构造了所需的六个点，以及分别为这六个点明确了相邻的三个点。注意，由于这里的点只有相邻和不相邻的位置关系，所以不需要在意这些点到底在三棱柱里对应哪个位置，任意设定这些点的位置对结果来说并没有影响，只需注意它们之间的相邻关系即可。 isLastOne函数判断是不是最后一个未涂色的点。 paintPoint函数用于对作为参数传入的点进行着色。其中首先通过调用该点的getLeftOverColors方法获取可用颜色，然后按照上文算法中介绍的，通过遍历可用颜色列表，为该点着色，如果该点不是最后一个点（通过isLastOne函数判断），就递归调用paintPoint函数为相邻的一个未着色的点着色，如果是，则将记下一次涂色方案。 运行代码，得到结果 - 264： Ok，于是这道题就在我们的计算机的帮助下，被成功解决掉了～ 如果大家有更好的方案解决这一算法问题，欢迎交流～","categories":[{"name":"Python","slug":"Python","permalink":"http://yuehaowang.github.io/categories/Python/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yuehaowang.github.io/tags/数学/"},{"name":"算法","slug":"算法","permalink":"http://yuehaowang.github.io/tags/算法/"},{"name":"Python","slug":"Python","permalink":"http://yuehaowang.github.io/tags/Python/"}]},{"title":"证明：sin'x = cosx","slug":"derivative-of-sinx","date":"2016-05-20T16:00:00.000Z","updated":"2017-02-01T14:42:20.000Z","comments":true,"path":"2016/05/21/derivative-of-sinx/","link":"","permalink":"http://yuehaowang.github.io/2016/05/21/derivative-of-sinx/","excerpt":"初三将近毕业的时候老爸给我买了几本数学相关的书籍。还把他的大学教材翻出来给我看，希望我去提前学习高等数学。很遗憾，当时的我对于这些东西完全不感兴趣，所以就不屑一顾，往书架上一扔就是两年。不久前，自己在数学教科书上看到了积分。书中运用积分的知识求得了一个曲边形的面积。当时我就傻眼了，什么！数学居然可以这么神奇。我这才意识到自己的无知，并且激起了我强烈的研究数学的欲望。这段时间里，我相继学习了导数和定积分，越发觉得数学的高深，决定提前学习大学里的高等数学。 大学课程中，第一个难题就是极限。有了它，才有导数、积分…… 经过一个半月的课余时间学习，我大致地掌握了极限的一些知识。于是我决定使用它来解决一个我在导数学习过程中的一个问题：证明sin’x = cosx。 以下是我经过研究，得出的证明过程。 证明过程首先根据导数定义，我们得到以下几个式子：","text":"初三将近毕业的时候老爸给我买了几本数学相关的书籍。还把他的大学教材翻出来给我看，希望我去提前学习高等数学。很遗憾，当时的我对于这些东西完全不感兴趣，所以就不屑一顾，往书架上一扔就是两年。不久前，自己在数学教科书上看到了积分。书中运用积分的知识求得了一个曲边形的面积。当时我就傻眼了，什么！数学居然可以这么神奇。我这才意识到自己的无知，并且激起了我强烈的研究数学的欲望。这段时间里，我相继学习了导数和定积分，越发觉得数学的高深，决定提前学习大学里的高等数学。 大学课程中，第一个难题就是极限。有了它，才有导数、积分…… 经过一个半月的课余时间学习，我大致地掌握了极限的一些知识。于是我决定使用它来解决一个我在导数学习过程中的一个问题：证明sin’x = cosx。 以下是我经过研究，得出的证明过程。 证明过程首先根据导数定义，我们得到以下几个式子： 这时候，我们证明以下式子成立，那么（4）成立： 根据三角函数倍角公式： （5）中左边式子化简得到： 所以（5）成立。证毕。 该方法由本人自行推导，对数学有所研究的朋友不妨告诉我一些更好的方法。","categories":[{"name":"其他","slug":"其他","permalink":"http://yuehaowang.github.io/categories/其他/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yuehaowang.github.io/tags/数学/"}]},{"title":"Web App：波的叠加演示","slug":"webapp-wave-superposition","date":"2016-04-23T16:00:00.000Z","updated":"2017-07-16T10:33:50.000Z","comments":true,"path":"2016/04/24/webapp-wave-superposition/","link":"","permalink":"http://yuehaowang.github.io/2016/04/24/webapp-wave-superposition/","excerpt":"最近物理学到波的叠加了。什么是波的叠加呢？简而言之，就是两个波传递到相同质点时，对该质点产生的共同作用。课堂上，物理老师使用flash动画为我们演示了正弦波的叠加方式。不过由于演示程序的用户体验不佳、学校电脑较难操作、老师使用不当等种种原因，为了播放这个动画，老师可费了不少功夫。由于我本来就对这部分内容比较感兴趣，所以抽空研究了一下，用HTML5 + JavaScript制作了一个Web App，用于演示波的叠加。截图如下：","text":"最近物理学到波的叠加了。什么是波的叠加呢？简而言之，就是两个波传递到相同质点时，对该质点产生的共同作用。课堂上，物理老师使用flash动画为我们演示了正弦波的叠加方式。不过由于演示程序的用户体验不佳、学校电脑较难操作、老师使用不当等种种原因，为了播放这个动画，老师可费了不少功夫。由于我本来就对这部分内容比较感兴趣，所以抽空研究了一下，用HTML5 + JavaScript制作了一个Web App，用于演示波的叠加。截图如下： 使用说明点击界面上的“Wave 1”和“Wave 2”按钮，将分别进入调节第一列波和第二列波的界面。Wavelength（波长λ）、Period（周期T）、Amplitude（振幅A）几个滑块控件用于控制波的属性。以下是这几个属性的取值范围： 波长（m） 周期（s） 振幅（m） [0.6, 5.0] [0.2, 2.0] [0.6, 2.0] 注意：1m = 30px Delay（延时）用于设定多少时间后波源开始运动；Origin（起源）用于设定波源起始的位置，左／右；Initial Direction（起振方向）用于设置波源开始振动的方向；Available用于设定是否开启这列波。 调整好以上几个属性后，点击“Start”按钮开始演示；点击“Stop”按钮停止演示；“Reset”按钮用于将以上属性调为初始值。 兼容平台如下表： iOS Android Google Chrome Firefox Opera Safari IE9+ √ √ √ √ √ √ √ 技术支持GUI使用HTML5 Canvas和lufylegend.js引擎 传送门在线使用地址 →Github项目地址 →下载地址 →P.S. （毕业典礼后追加）话说这个小工具做出来也有一段时间了，结果我一直拖到毕业典礼才拿去送给了我的物理老师。听到物理老师说了句：你自己做的吗？诶，还是厉害诶～，瞬间觉得成就感MAX，^v^!! 如果本作出现bug，请及时联系我～","categories":[{"name":"App发布","slug":"App发布","permalink":"http://yuehaowang.github.io/categories/App发布/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yuehaowang.github.io/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://yuehaowang.github.io/tags/canvas/"},{"name":"lufylegend","slug":"lufylegend","permalink":"http://yuehaowang.github.io/tags/lufylegend/"},{"name":"App","slug":"App","permalink":"http://yuehaowang.github.io/tags/App/"},{"name":"物理模拟","slug":"物理模拟","permalink":"http://yuehaowang.github.io/tags/物理模拟/"}]},{"title":"JavaScript计算圆周率（解析几何+定积分）","slug":"js-calcu-pi","date":"2016-03-25T16:00:00.000Z","updated":"2016-04-29T11:12:26.000Z","comments":true,"path":"2016/03/26/js-calcu-pi/","link":"","permalink":"http://yuehaowang.github.io/2016/03/26/js-calcu-pi/","excerpt":"最近数学预习到选修本的定积分，前一向用它解决了物理上的正弦交流电有效值问题，前几天突发奇想，想用它来计算圆周率。于是我花了半节物理课的时间研究了一下，得出了以下求解方法。 首先我们知道半径为r，圆心为(0, 0)的圆的方程是： 不过这个是个方程，无法使用积分求解，所以我们要对它进行变形，变成一个函数。根据本人多年刷题经验，要把其变为函数，只需取一个半圆即可，获取半圆则需将其变形为：","text":"最近数学预习到选修本的定积分，前一向用它解决了物理上的正弦交流电有效值问题，前几天突发奇想，想用它来计算圆周率。于是我花了半节物理课的时间研究了一下，得出了以下求解方法。 首先我们知道半径为r，圆心为(0, 0)的圆的方程是： 不过这个是个方程，无法使用积分求解，所以我们要对它进行变形，变成一个函数。根据本人多年刷题经验，要把其变为函数，只需取一个半圆即可，获取半圆则需将其变形为： 由于算术平方根运算得到的值 &gt; 0，所以该函数y就是以x为自变量的一个图像为半圆的函数。 现在取[-r, r]定积分值得到半圆面积。 最终得到如下几个数学表达式求出圆周率： 接下来的步骤就是求定积分的值了。如果要用牛顿—莱布尼茨公式，需要去找F(x)，F’(X) = y(x)。不过这个寻找的过程比较复杂（至少对于我而言是无法找到的，找到了该函数的朋友不妨告诉我一声？），所以我就直接通过程序计算来实现获取面积近似值。正如定积分所定义，我们可以用如下示意图来理解如何获取面积近似值： 当我们把半圆分割为n（n为无穷大）个矩形，那么这个半圆面积就是这n个矩形的面积之和。 有了以上理论，就不难使用代码来实现了：12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Calculate PI&lt;/title&gt; &lt;script type=\"text/javascript\"&gt; var r = 1, dx = 0.00000001, upperLimit = r; function y (x) &#123; return Math.sqrt(r * r - x * x); &#125; function main () &#123; var s = 0; for (var x = -r; x &lt; upperLimit; x += dx) &#123; s += dx * y(x); &#125; var pi = (s * 2) / (r * r); document.write(\"Calculational Value: \" + pi); document.write(\"&lt;br /&gt;\"); document.write(\"Theoretical Value: 3.1415926535897932\"); &#125; main(); &lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt; 输出结果： 由于我们只能得到近似值，所以得到的圆周率和实际情况有差异。如果将半圆分得越细，那么得到的近似值越接近真实值。 该方法由本人自行研发，所以可能存在不足之处，如果大家知道更好的方式来求解圆周率，欢迎分享交流。","categories":[{"name":"HTML5&JavaScript","slug":"HTML5-JavaScript","permalink":"http://yuehaowang.github.io/categories/HTML5-JavaScript/"}],"tags":[{"name":"数学","slug":"数学","permalink":"http://yuehaowang.github.io/tags/数学/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"}]},{"title":"Python开发接水果小游戏","slug":"python-game-dev-get-fruits","date":"2016-02-15T16:00:00.000Z","updated":"2017-07-17T05:42:39.000Z","comments":true,"path":"2016/02/16/python-game-dev-get-fruits/","link":"","permalink":"http://yuehaowang.github.io/2016/02/16/python-game-dev-get-fruits/","excerpt":"我研发的Python游戏引擎Pylash已经更新到1.4.0了。现在我们就来使用它完成一个极其简单的小游戏：接水果。以下是游戏截图： 游戏操作说明：点击屏幕左右两边或者使用键盘方向键控制人物移动，使人物与水果接触得分，碰到非水果的物品，如碎玻璃，就会game over。 创建项目首先在工作目录创建一个名为get_fruits的目录。然后到Github下载Pylash。引擎是基于Python3和PyQt4构建的，所以在使用前请确保你使用的是Python3并且安装了PyQt4。如果没有，可以在上述项目地址中找到他们的相关网页链接进行下载安装，安装和配置步骤都十分简单。这里不再赘述。 下载完Pylash后，我们得到这样的目录结构： 1234567+- pylash_engine/ | +- pylash/ | +- demo/ | +- examples/","text":"我研发的Python游戏引擎Pylash已经更新到1.4.0了。现在我们就来使用它完成一个极其简单的小游戏：接水果。以下是游戏截图： 游戏操作说明：点击屏幕左右两边或者使用键盘方向键控制人物移动，使人物与水果接触得分，碰到非水果的物品，如碎玻璃，就会game over。 创建项目首先在工作目录创建一个名为get_fruits的目录。然后到Github下载Pylash。引擎是基于Python3和PyQt4构建的，所以在使用前请确保你使用的是Python3并且安装了PyQt4。如果没有，可以在上述项目地址中找到他们的相关网页链接进行下载安装，安装和配置步骤都十分简单。这里不再赘述。 下载完Pylash后，我们得到这样的目录结构： 1234567+- pylash_engine/ | +- pylash/ | +- demo/ | +- examples/ 大家可以在demo/和examples/两个目录下查看示例。本文的源代码可以在examples/get_fruits中找到。 pylash目录就是引擎源代码。接下来把这个目录复制到我们创建的get_fruits目录下，再在get_fruits目录下创建一个images目录，用于储存图片。最后创建一个Main.py文件。这时，我们的get_fruits目录结构如下： 1234567+- get_fruits/ | +- pylash/ | +- images/ | +- Main.py 然后将引擎目录plash_engine/examples/get_fruits/images/下图片复制到项目目录get_fruits/images/下，用作游戏素材。 这样一来，我们的项目就创建好了，接下来只用往Main.py里填写代码，然后运行即可。 编写Hello World小程序用代码编辑器（推荐Sublime Text）打开Main.py文件，写入以下代码： 1234567891011121314151617181920212223# !/usr/bin/env python3# -*- coding: utf-8 -*-from pylash.utils import init, addChildfrom pylash.text import TextFielddef main(): # 创建文本显示对象 txt = TextField() # 设置文本内容 txt.text = \"Hello World\" # 设置文本颜色 txt.textColor = \"red\" # 设置文本位置 txt.x = 50 txt.y = 100 # 设置文本字体大小 txt.size = 50 # 将文本对象加入到最底层 addChild(txt)# 初始化窗口，参数：界面刷新时间（单位：毫秒），窗口标题，窗口宽度，窗口高度，初始化完毕后回调函数init(1000 / 60, \"Hello World\", 800, 600, main) 运行Main.py，如果得到了如下图所示的界面，说明程序正常运转起来了。 大家可以结合注释初步认识Pylash。熟悉flash的同学不难发现，TextField就是flash里显示文本的类，而且用法十分相近。我们从代码的第4行看起，这里我们引入了pylash中的一些函数和类。pylash提供了很多模块，大家可以到这里查看它们的简介。再往下看，我们会发现，pylash提供了一个用于显示文本的类，通过设置这个类的不同属性来设定文本样式。最后使用addChild将文本显示对象加入到界面中。我们可以把游戏看作分为很多层：地图层、人物层、UI层……，通过分层我们就能实现层次化显示效果。比如人物一直是在地图上方显示的，那么人物层就在地图层上方。addChild函数就是把一个显示对象加到最底层。最后，我们使用init函数初始化窗口。 Pylash提供了许多基础显示对象，除了TextField文本显示类，还有Bitmap图片显示类，Sprite精灵类等。下文会提及。 编写游戏有了上述对pylash的大致了解，我们就可以开始编写游戏了。首先，删除第四行以后所有代码。 引入所需首先引入我们所需的所有类和函数，修改Main.py： 123456from pylash.utils import stage, init, addChild, KeyCodefrom pylash.system import LoadManagefrom pylash.display import Sprite, BitmapData, Bitmap, FPSfrom pylash.text import TextField, TextFormatWeightfrom pylash.events import MouseEvent, Event, KeyboardEventfrom pylash.ui import LoadingSample1 这些类和函数在下面的代码中都会被用到。由于我是提前写好了游戏，所以在这里把这部分代码一块儿贴出来了，大家使用的时候可以根据自己使用情况，每用一个引入一个。 全局变量游戏中需要用到一些全局变量，大家可以先浏览一遍，不同知道它们是干什么的，后文会用到它们： 12345678910dataList = &#123;&#125;stageLayer = Noneplayer = NoneitemLayer = NonescoreTxt = NoneaddItemSpeed = 40addItemSpeedIndex = 0score = 0keyboardEnabled = False 加载资源我们的游戏中要用到图片，所以要提前加载图片（存储于images/目录下）。加载图片我们用到LoadManage静态类和LoadingSample1进度条类（还有LoadingSample2、LoadingSample3这两款不同样式的进度条。或者大家深入学习后，可以自己写一个进度条类）。修改main函数： 1234567891011121314151617181920212223242526272829def main(): # 资源列表，一个list对象，格式：&#123;\"name\" : 资源名称, \"path\" : 资源路径&#125; loadList = [ &#123;\"name\" : \"player\", \"path\" : \"./images/player.png\"&#125;, &#123;\"name\" : \"bg\", \"path\" : \"./images/bg.jpg\"&#125;, &#123;\"name\" : \"item0\", \"path\" : \"./images/item0.png\"&#125;, &#123;\"name\" : \"item1\", \"path\" : \"./images/item1.png\"&#125;, &#123;\"name\" : \"item2\", \"path\" : \"./images/item2.png\"&#125;, &#123;\"name\" : \"item3\", \"path\" : \"./images/item3.png\"&#125;, &#123;\"name\" : \"item4\", \"path\" : \"./images/item4.png\"&#125;, &#123;\"name\" : \"item5\", \"path\" : \"./images/item5.png\"&#125;, &#123;\"name\" : \"item6\", \"path\" : \"./images/item6.png\"&#125;, &#123;\"name\" : \"item7\", \"path\" : \"./images/item7.png\"&#125; ] # 创建进度条 loadingPage = LoadingSample1() addChild(loadingPage) # 加载完成后调用的函数，接受一个参数，该参数是一个dict对象，通过result[资源名称]来获取加载完成的资源 def loadComplete(result): # 调用remove方法从界面上移除自身 loadingPage.remove() # 调用初始化游戏函数 gameInit(result) # 加载文件，参数：资源列表，每加载完一个资源回调函数（多用于显示进度），加载完所有资源回调函数 LoadManage.load(loadList, loadingPage.setProgress, loadComplete) 上述代码含有详细注释，理解起来应该不算困难。可以看到，我们使用LoadManage.load实现加载。LoadingSample1.setProgress用于设置显示进度。 创建开始界面我们在main函数中调用了gameInit函数，所以添加该函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960def gameInit(result): global dataList, stageLayer # 保存加载完成的资源，这样一来，就可以使用dataList[资源名称]来获取加载完成的资源 dataList = result # 创建舞台层 stageLayer = Sprite() addChild(stageLayer) # 加入FPS，方便查看游戏效率 fps = FPS() addChild(fps) # 加入背景图片 bg = Bitmap(BitmapData(dataList[\"bg\"])) stageLayer.addChild(bg) # 加入文本 titleTxt = TextField() titleTxt.text = \"Get Furit\" titleTxt.size = 70 titleTxt.textColor = \"red\" titleTxt.x = (stage.width - titleTxt.width) / 2 titleTxt.y = 100 stageLayer.addChild(titleTxt) hintTxt = TextField() hintTxt.text = \"Tap to Start the Game!~\" hintTxt.textColor = \"red\" hintTxt.size = 40 hintTxt.x = (stage.width - hintTxt.width) / 2 hintTxt.y = 300 stageLayer.addChild(hintTxt) engineTxt = TextField() engineTxt.text = \"- Powered by Pylash -\" engineTxt.textColor = \"red\" engineTxt.size = 20 engineTxt.weight = TextFormatWeight.BOLD engineTxt.italic = True engineTxt.x = (stage.width - engineTxt.width) / 2 engineTxt.y = 500 stageLayer.addChild(engineTxt) # 加入鼠标点击事件：点击舞台层后，开始游戏 stageLayer.addEventListener(MouseEvent.MOUSE_UP, startGame) # 加入键盘事件：用于控制游戏中的人物 stage.addEventListener(KeyboardEvent.KEY_DOWN, keyDown) stage.addEventListener(KeyboardEvent.KEY_UP, keyUp)def startGame(e): print(\"start game\")def keyDown(e): print(\"key down\")def keyUp(e): print(\"key up\") 上述代码中，我们需要突破以下几个难点： Sprite精灵类。Sprite是一个精灵类。可是什么是精灵？其实你可以把它理解为一个层。它拥有addChild方法，用于把显示对象加到自身这个层上（和全局的addChild函数类似）。当然Sprite不只是有层的功能，不过你姑且把它看作一个层吧。 Bitmap和BitmapData类的使用。Bitmap在上文中提到是一个用于显示图片的类。和TextField一样，使用addChild将它加入界面。BitmapData类是用于储存图像数据的，它接收的参数就是加载完成的图片资源。将他作为参数传给Bitmap类的构造器，就能创建出图片。BitmapData还可以进行像素操作，不过这是较高级的功能，目前不用了解。 事件。在pylash中，使用addEventListener统一接口加入事件，该方法参数：事件类型，事件监听器（即事件回调函数）。什么是事件呢？类似于一个信号，这个信号在某种情况下被发送后，指定的信号监听器就会被触发。这里添加鼠标事件的addEventListener是在EventDispatcher中定义的，DisplayObject类继承自EventDispatcher，所以继承自DisplayObject的所有类，都能加入事件。不过只有Sprite才有触发鼠标事件的能力。所以我们给stageLayer（舞台层，一个Sprite对象）加入了鼠标点击事件（MouseEvent.MOUSE_UP）。对应addEventListener方法的有removeEventListener（移除事件，参数相同）。鼠标事件除了MouseEvent.MOUSE_UP（鼠标弹起），还有MouseEvent.MOUSE_DOWN（鼠标按下），MouseEvent.MOUSE_MOVE（鼠标移动），MouseEvent.MOUSE_OUT（鼠标移出）等事件。后文会用到一些。事件的监听器是一个函数，startGame、keyDown、keyUp它们都是事件监听器。监听器在事件触发时被调用，并接受一个事件数据参数（通常写为e），通过这个参数可以获取事件的一些信息，如鼠标事件的监听器可以通过该参数获取鼠标位置。 stage全局类。这里的stage是一个全局类，用于管理整个窗口，比如设置窗口刷新速度、获取窗口尺寸（stage.width，stage.height），有点类似于JavaScript里的window。键盘事件总不能加到某个对象上吧，所以stage还能加入键盘事件。加入键盘事件同样使用addEventListener这个的统一接口。 最后加入init函数初始化窗口： 1init(1000 / 60, \"Get Fruits\", 800, 600, main) init函数中，值得注意的是第一个参数，上文代码的注释中解释的是“界面刷新时间”，也就是说我们的界面是在不断刷新重绘的。这个参数就是用来决定刷新的时间。参数值越小，刷新得越快，游戏越流畅，不过也不用设置得太小，太小了话，刷新速度过快，设备会跟不上这个节奏的。玩过游戏的朋友可以这么理解这个参数，用1000除以这个参数，得到的就是FPS。 运行Main.py，得到如下界面： 可以看到，我们的界面上有图片也有文本。点击界面输出“start game”，按下键盘输出“key down”，释放键盘输出“key up”。这样一来，我们就成功地添加了显示对象和鼠标&amp;键盘事件。 开始游戏舞台层鼠标点击事件的监听器是startGame函数，也就是说，我们点击开始界面就开始游戏。修改startGame函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051def startGame(e): global player, itemLayer, scoreTxt, addItemSpeedIndex, score, keyboardEnabled # 初始一些全局变量 addItemSpeedIndex = 0 score = 0 keyboardEnabled = True # 清空舞台层和舞台事件 stageLayer.removeAllChildren() stageLayer.removeAllEventListeners() # 加入背景 bg = Bitmap(BitmapData(dataList[\"bg\"])) stageLayer.addChild(bg) # 创建角色 player = Player(dataList[\"player\"]) player.x = (stage.width - player.width) / 2 player.y = 450 stageLayer.addChild(player) # 创建下落物品层 itemLayer = Sprite() stageLayer.addChild(itemLayer) # 将人物对象保存到itemLayer中，用于检测碰撞 itemLayer.hitTarget = player # 加入分数文本 scoreTxt = TextField() scoreTxt.text = \"Score: 0\" scoreTxt.textColor = \"red\" scoreTxt.size = 30 scoreTxt.x = scoreTxt.y = 30 scoreTxt.weight = TextFormatWeight.BOLDER stageLayer.addChild(scoreTxt) # 加入事件 stageLayer.addEventListener(MouseEvent.MOUSE_DOWN, onMouseDown) stageLayer.addEventListener(MouseEvent.MOUSE_UP, onMouseUp) stageLayer.addEventListener(Event.ENTER_FRAME, loop)def onMouseDown(e): print(\"mouse down\")def onMouseUp(e): print(\"mouse up\")def loop(e): print(\"loop\") 对应addChild，Sprite提供了removeChild方法用于移除显示对象。除此之外还有removeAllChildren移除所有对象方法。removeAllEventListeners顾名思义就是移除所有事件。上面的代码会让人一头雾水，同样的，我们需要突破以下难关： 全局变量。addItemSpeedIndex是用于控制添加下落物品的时间间隔，后文会提及。score是保存分数的变量。由于游戏开始后，这些变量要回到初始值，所以在startGame函数中添加了这些代码来完成这项任务。keyboardEnabled = True这行代码是用于打开键盘事件，键盘事件是加到stage对象上的（见上文），但是是用于操作游戏中主角的，所以只有在游戏开始后才有用，所以加入keyboardEnabled变量作为能否使用键盘的开关，后文修改键盘事件监听器时会用到它。 Player类。这个类是我们要自己创建的人物类，后文会展示其代码。 时间轴事件ENTER_FRAME。我们了解了鼠标事件，认识MouseEvent.MOUSE_DOWN、MouseEvent.MOUSE_UP，可是Event.ENTER_FRAME是什么东西-_-#？这个事件就是时间轴事件。时间轴事件类似于一个计时器。这个事件的监听器每隔段事件就会触发。事件触发的时间间隔取决于init函数的第一个参数。 运行代码，点击开始界面开始游戏，你可以发现控制台在不停地输出“loop”，代表时间轴事件运转了。 Player人物类上文提到了这个类，在写这个类之前，我们重新在get_fruits/目录下创建一个名为Player.py的python文件。创建完成后，打开这个文件，加入以下代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pylash.utils import stagefrom pylash.display import Sprite, Animation, BitmapData# 创建Player类，并使其继承自Sprite类class Player(Sprite): def __init__(self, playerImage): super(Player, self).__init__() # 移动方向，【right向右，left向左，None不移动】 self.direction = None # 移动速度 self.step = 5 # 创建图片数据 bmpd = BitmapData(playerImage) # 创建动画帧列表 frames = Animation.divideUniformSizeFrames(bmpd.width, bmpd.height, 4, 4) # 创建动画 self.animation = Animation(bmpd, frames) # 设置动画播放速度 self.animation.speed = 5 # 播放动画 self.animation.play() # 将动画加入界面 self.addChild(self.animation) def loop(self): # 向右移动 if self.direction == \"right\": self.x += self.step # 播放向右移动时的动画 self.animation.currentRow = 2 # 向左移动 elif self.direction == \"left\": self.x -= self.step # 播放向左移动时的动画 self.animation.currentRow = 1 # 不移动 else: # 播放不移动时的动画 self.animation.currentRow = 0 # 限制人物位置 if self.x &lt; 0: self.x = 0 elif self.x &gt; stage.width - self.width: self.x = stage.width - self.width 这个Player类需要继承自Sprite，使其成为一个显示对象。也就是说继承自Sprite后，就可以被addChild到界面上去了，并可以显示出来。除此之外，还可以使用Player对象的addChild方法来向人物类添加显示元件。Player类的构造器接收一个人物图片参数。代码中用到了Animation类。它由pylash提供，用于创建简单的基于图片的动画。Animation构造器接收两个参数：动画位图数据，动画帧列表。 一般而言，我们的动画用的图片都是这样的: 所以我们播放动画的时候，只需要控制位图显示区域的大小和位置就能实现播放动画。类似于放映机放映电影。如下两幅图所示，显示区域就是空白部分，不被显示的区域就是被半透明黑色幕布遮住的部分。动画中的每个小图叫帧，移动显示区域就实现切换帧，达到播放动画的目的。 代码中的Animation.divideUniformSizeFrames(bmpd.width, bmpd.height, 4, 4)就是用于获取每帧的位置和大小。divideUniformSizeFrames静态方法接收四个参数：动画图片宽度，动画图片高度，动画列数，动画行数。该方法只适合得到每帧分布和大小都是均匀的帧列表。 Animation有个speed属性，用于控制动画播放速度。如果不设置这个属性，动画中每帧的切换速度就和init中设置的刷新速度一样。设置后，切换速度变为speed * 刷新速度。 Animation类默认只播放第一排第一行动画，要指定动画播放的位置，需要设置currentRow和currentColumn属性来控制播放的行和列。 下落物品类：Item这个类在前面没出现过，不过我们先写好放在这里，下文要用到。同样的，新建一个名为Item.py的文件，打开它，写入代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546from pylash.utils import stagefrom pylash.display import Sprite, Bitmap, BitmapDataclass Item(Sprite): # 定义自定义事件 EVENT_ADD_SCORE = \"event_add_score\" EVENT_GAME_OVER = \"event_game_over\" def __init__(self, image): super(Item, self).__init__() bmp = Bitmap(BitmapData(image)) self.addChild(bmp) self.index = 0 self.y = -bmp.height / 2 def loop(self): player = None # 获取人物对象 if self.parent: player = self.parent.hitTarget if player is None: return # 向下移动 self.y += 5 # 碰撞检测 if (abs(self.x + self.width / 2 - player.x - player.width / 2) &lt;= (self.width + player.width) / 2) and (abs(self.y + self.height / 2 - player.y - player.height / 2) &lt;= (self.height + player.height) / 2): # 如果index &lt;= 3，代表物品是水果 if self.index &lt;= 3: # 触发自定义事件：加分事件 self.dispatchEvent(Item.EVENT_ADD_SCORE) self.remove() # 如果物品是非水果 else: # 触发自定义事件：游戏结束 self.dispatchEvent(Item.EVENT_GAME_OVER) # 移除自身，当自身移出了屏幕 if self.y &gt;= stage.height: self.remove() Item类的构造器和Player构造器一样，接受一个图片参数。我们这里用到了一个比较高级的功能：自定义事件。自定的事件可以是一个字符串，作为该事件的标识。使用dispatchEvent方法触发事件。dispatchEvent方法在EventDispatcher中定义，通过继承使Item也能使用这个方法。值得关注的还有检测碰撞部分。目前处理简单的矩形碰撞即可。首先来看张图： 如果要横向判断碰撞的话，判断(x1-x2)的绝对值是否小于或者等于w1/2+w2/2，如果是则横向则有碰撞。纵向判断是一样的，判断(y1-y2)的绝对值是否小于或等于h1/2+h2/2即可。 修改事件监听器上面的代码中我们虽然添加了事件，但是没有添加有效的事件监听器，所以修改这些函数： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859def keyDown(e): global player if not keyboardEnabled or not player: return if e.keyCode == KeyCode.KEY_RIGHT: player.direction = \"right\" elif e.keyCode == KeyCode.KEY_LEFT: player.direction = \"left\"def keyUp(e): global player if not keyboardEnabled or not player: return player.direction = Nonedef onMouseDown(e): global player if e.offsetX &gt; (stage.width / 2): player.direction = \"right\" else: player.direction = \"left\"def onMouseUp(e): global player player.direction = Nonedef loop(e): global player, itemLayer, addItemSpeed, addItemSpeedIndex player.loop() for o in itemLayer.childList: o.loop() # 控制添加下落物品时间间隔 if addItemSpeedIndex &lt; addItemSpeed: addItemSpeedIndex += 1 return addItemSpeedIndex = 0 # 获得随机下落物品 randomNum = random.randint(0, 7) # 加入下落物品 item = Item(dataList[\"item\" + str(randomNum)]) item.index = randomNum item.x = int(random.randint(30, stage.width - 100)) itemLayer.addChild(item) # 加入自定义的事件 item.addEventListener(Item.EVENT_ADD_SCORE, addScore) item.addEventListener(Item.EVENT_GAME_OVER, gameOver) keyDown、keyUp、onMouseDown、onMouseUp这四个监听器用于操作人物（player）。 接下来看监听器loop。该函数中，首先调用了人物的loop方法（见Player类的loop）。我们在上文定义的itemLayer是一个Sprite对象，Sprite对象有一个childList属性，是一个list对象，保存了所有的子对象。所以我们通过遍历itemLayer的这个列表，获取每个下落物品，调用它们的loop方法。接下来使用addItemSpeedIndex和addItemSpeed两个全局变量控制加入下落物品的速度。接下来的代码就是来构造Item类创建下落物品。 加分和Game Over我们给Item对象加入了自定义事件，分别触发addScore和gameOver监听器，加入这两个监听器： 123456789101112131415161718192021222324252627282930313233343536def addScore(e): global score, scoreTxt score += 1 scoreTxt.text = \"Score: %s\" % scoredef gameOver(e): global player, scoreTxt, stageLayer, keyboardEnabled keyboardEnabled = False stageLayer.removeAllEventListeners() scoreTxt.remove() player.animation.stop() resultTxt = TextField() resultTxt.text = \"Final Score: %s\" % score resultTxt.size = 40 resultTxt.weight = TextFormatWeight.BOLD resultTxt.textColor = \"orangered\" resultTxt.x = (stage.width - resultTxt.width) / 2 resultTxt.y = 250 stageLayer.addChild(resultTxt) hintTxt = TextField() hintTxt.text = \"Double Click to Restart\" hintTxt.size = 35 hintTxt.textColor = \"red\" hintTxt.x = (stage.width - hintTxt.width) / 2 hintTxt.y = 320 stageLayer.addChild(hintTxt) # 加入双击事件，点击后重新开始游戏 stageLayer.addEventListener(MouseEvent.DOUBLE_CLICK, startGame) 运行Main.py，开始游戏后，得到本文开篇图片所示效果。移动人物，接触下落的物品。如果碰到碎玻璃等非水果物品就会game over： Ok，我们的接水果小游戏就完成了。可见使用python+pylash开发小游戏还是很方便的。 源代码本文的源代码可以在引擎目录的examples/get_fruits中找到。或者到这里在线查看。 文中有任何不妥之处或者读者有疑问的话，欢迎大家交流～","categories":[{"name":"Python","slug":"Python","permalink":"http://yuehaowang.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://yuehaowang.github.io/tags/Python/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yuehaowang.github.io/tags/游戏开发/"},{"name":"Pylash","slug":"Pylash","permalink":"http://yuehaowang.github.io/tags/Pylash/"}]},{"title":"使用lufylegend实现游戏中的卷轴","slug":"game-screen-scrolling","date":"2016-02-09T16:00:00.000Z","updated":"2017-02-01T14:43:38.000Z","comments":true,"path":"2016/02/10/game-screen-scrolling/","link":"","permalink":"http://yuehaowang.github.io/2016/02/10/game-screen-scrolling/","excerpt":"什么是卷轴玩过RPG或者横版格斗的同学应该知道，人物走到屏幕中央后，由于地图过大，地图会进行移动，人物则相对静止不动。这个就是传说中的卷轴。例如下图是我的游戏“三国战线”里的卷轴： 有了以上的简介，大家应该明白了什么是卷轴。说白了就是镜头跟随主角的效果。接下来，我们就利用lufylegend.js游戏引擎来实现这个效果。","text":"什么是卷轴玩过RPG或者横版格斗的同学应该知道，人物走到屏幕中央后，由于地图过大，地图会进行移动，人物则相对静止不动。这个就是传说中的卷轴。例如下图是我的游戏“三国战线”里的卷轴： 有了以上的简介，大家应该明白了什么是卷轴。说白了就是镜头跟随主角的效果。接下来，我们就利用lufylegend.js游戏引擎来实现这个效果。 原理介绍其实实现这个效果的关键在于如何使人物静止，何时移动地图，以及如何移动地图。在探究这个两个问题之前，我们先创建一个结构良好的舞台层（及一个LSprite对象），以便以后的操作。舞台结构如下： 12345+- 舞台层 | +- 地图层 | +- 人物层 可见舞台层就是地图层和人物层的父元素，并且人物层在地图层上方，毕竟人物是站在地图上的。我们知道，子对象的坐标是相对于父对象的，所以移动父对象，子对象会跟着移动。这点要先弄明白。 如何使人物静止呢？何时移动地图呢？如何移动地图呢？也许你会想，首先用if(xxx){...}来判断人物的坐标是否达到屏幕中央，如果是，则移动地图对象，如果不是则移动人物对象。这么做的话就麻烦了。其实有更简单的方法：卷轴/不卷轴时，我们的人物都是在移动，但是如果人物达到屏幕中央时，要开始卷轴了，我们的舞台层就进行与人物速度方向相反、大小相同的移动，那么人物的相对于canvas画布的位移就抵消了，看上去就是静止的，而地图就跟着父类向反方向移动。这个类似于拍古装电影，拍两个人一边骑马一边谈话。如果人和马在前进，摄像机以相同的速度跟拍，那么得到的画面就是人物并没有移动，而人物背后风景是在移动的。 接下来看实现代码。 实现代码以下是含有详细注释的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394LInit(30, \"mydemo\", 700, 480, main);// 移动方向，null代表没移动var direction = null;// 小鸟，舞台层，背景对象var bird, stageLayer, bg;// 每次移动的长度var step = 5;function main () &#123; // 资源列表 var loadList = [ &#123;name : \"bird\", path : \"./bird.png\"&#125;, &#123;name : \"bg\", path : \"./bg.jpg\"&#125; ]; // 加载资源 LLoadManage.load(loadList, null, demoInit);&#125;function demoInit (result) &#123; // 初始化舞台层 stageLayer = new LSprite(); addChild(stageLayer); // 加入背景 bg = new LBitmap(new LBitmapData(result[\"bg\"])); bg.y = -100; stageLayer.addChild(bg); // 加入小鸟 bird = new LBitmap(new LBitmapData(result[\"bird\"])); bird.x = 100; bird.y = 150; stageLayer.addChild(bird); // 添加鼠标按下事件 stageLayer.addEventListener(LMouseEvent.MOUSE_DOWN, onDown); // 添加鼠标弹起事件 stageLayer.addEventListener(LMouseEvent.MOUSE_UP, onUp); // 添加时间轴事件 stageLayer.addEventListener(LEvent.ENTER_FRAME, onFrame);&#125;function onDown (e) &#123; /** 根据点击位置设置移动方向 */ if (e.offsetX &gt; LGlobal.width / 2) &#123; direction = \"right\"; &#125; else &#123; direction = \"left\"; &#125;&#125;function onUp () &#123; // 设置方向为无方向，代表不移动 direction = null;&#125;function onFrame () &#123; var _step, minX, maxX; /** 移动小鸟 */ if (direction == \"right\") &#123; _step = step; &#125; else if (direction == \"left\") &#123; _step = -step; &#125; else &#123; return; &#125; bird.x += _step; /** 控制小鸟移动范围 */ minX = 0, maxX = bg.getWidth() - bird.getWidth(); if (bird.x &lt; minX) &#123; bird.x = minX; &#125;else if (bird.x &gt; maxX) &#123; bird.x = maxX; &#125; /** 移动舞台 */ stageLayer.x = LGlobal.width / 2 - bird.x; /** 控制舞台移动范围 */ minX = LGlobal.width - stageLayer.getWidth(), maxX = 0; if (stageLayer.x &lt; minX) &#123; stageLayer.x = minX; &#125;else if (stageLayer.x &gt; maxX) &#123; stageLayer.x = maxX; &#125;&#125; 运行结果： 大家可以到这里查看在线演示。点击屏幕左半边控制小鸟向左移动，点击右半边屏幕，控制小鸟向右移动。小鸟到达屏幕中央后，开始卷轴。 源代码下载点击下载","categories":[{"name":"HTML5&JavaScript","slug":"HTML5-JavaScript","permalink":"http://yuehaowang.github.io/categories/HTML5-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"http://yuehaowang.github.io/tags/HTML5/"},{"name":"canvas","slug":"canvas","permalink":"http://yuehaowang.github.io/tags/canvas/"},{"name":"lufylegend","slug":"lufylegend","permalink":"http://yuehaowang.github.io/tags/lufylegend/"},{"name":"游戏开发","slug":"游戏开发","permalink":"http://yuehaowang.github.io/tags/游戏开发/"}]},{"title":"JavaScript类的小小研究","slug":"research-of-js-class","date":"2016-02-07T16:00:00.000Z","updated":"2016-07-23T13:55:08.000Z","comments":true,"path":"2016/02/08/research-of-js-class/","link":"","permalink":"http://yuehaowang.github.io/2016/02/08/research-of-js-class/","excerpt":"基础知识JavaScript中的类JavaScript实际上是一种弱类型语言，与C++和Java等语言不同。因此，在JavaScript中，没有强调类（class）这一概念，但实际运用中，类还是很重要的，比如写一款游戏，如果我们不停地调用函数来完成创建角色，移动角色的话，那会是什么样的呢？可能会出现非常多的重复代码，因此我们需要一个类来统一这些代码。所谓的类，就是把程序中的代码分类，比如说游戏中的关于角色的代码算作一类，游戏背景算作一类，游戏特效又是一类。这样一来，我们对类进行操作，就不会使代码显得很凌乱，冗杂。虽然Js是弱类型语言，但是也提供了类这一概率。定义Js中的类，实际上用的是function，总所周知，这个语法其实是用来定义函数的。不同于定义函数的是，我们可以在function中通过this.xxx的方式来定义属性和方法。比如说：1234567function People () &#123; this.name = \"Yorhom\"; this.getName = function () &#123; return this.name &#125;;&#125;","text":"基础知识JavaScript中的类JavaScript实际上是一种弱类型语言，与C++和Java等语言不同。因此，在JavaScript中，没有强调类（class）这一概念，但实际运用中，类还是很重要的，比如写一款游戏，如果我们不停地调用函数来完成创建角色，移动角色的话，那会是什么样的呢？可能会出现非常多的重复代码，因此我们需要一个类来统一这些代码。所谓的类，就是把程序中的代码分类，比如说游戏中的关于角色的代码算作一类，游戏背景算作一类，游戏特效又是一类。这样一来，我们对类进行操作，就不会使代码显得很凌乱，冗杂。虽然Js是弱类型语言，但是也提供了类这一概率。定义Js中的类，实际上用的是function，总所周知，这个语法其实是用来定义函数的。不同于定义函数的是，我们可以在function中通过this.xxx的方式来定义属性和方法。比如说：1234567function People () &#123; this.name = \"Yorhom\"; this.getName = function () &#123; return this.name &#125;;&#125; 使用的时候使用new：123var yorhom = new People();// \"Yorhom\"alert(yorhom.getName()); 可以看到，这样就可以使用到我们定义的类和类中的方法了。也许你会问this.xxx只能定义公有属性和方法，那私有属性和方法怎么办呢？这个可以用到js闭包的知识来解决：12345678910111213141516171819function People () &#123; this.name = \"Yorhom\"; var age = 16; this.getName = function () &#123; return this.name &#125;; this.getAge = function () &#123; return age; &#125;;&#125;var yorhom = new People();// undefinedalert(yorhom.age);// 16alert(yorhom.getAge()); 可以看到，这里的age就是一个私有属性了。 JavaScript中的prototype上面的代码美中不足的地方就是，如果一个类有很多方法，同时用到这个类的地方又有很多（也就是new出来的对象有很多），那么用上面的代码就会出现内存占用过盛的问题。问题的根本原因在于，每次实例化一个对象，这个类就会执行构造器里的代码（以People类为例就是执行function People () {...}），因此每当这个类被实例化的时候，这些方法和属性就会被拷贝到实例化出来的对象中。这样一来，就会造成“吃”内存的现象。于是js中的prototype就诞生了。prototype的作用通常是给一个类添加一系列属性或者方法。 每当一个类被实例化之后，实例化出来的对象会自动获取类的prototype中定义的方法和属性。只不过这里的获取方式类似于C++里面的引用，不会在内存里对这些方法和属性进行复制，而是指向这些方法和属性。示例：1234567891011function People () &#123; this.name = \"Yorhom\";&#125;People.prototype.getName = function () &#123; return this.name;&#125;;var yorhom = new People();// \"Yorhom\"alert(yorhom.getName()); 这种方法虽然可以节约内存，但是，美中不足的是，无法定义私有属性。 类的继承Javascript没有提供继承的函数，所以只有自己写了。这里借用lufylegend.js中的继承方法向大家展示如何实现继承：1234567891011121314function base (d, b, a) &#123; var p = null, o = d.constructor.prototype, h = &#123;&#125;; for (p in o) &#123; h[p] = 1; &#125; for (p in b.prototype) &#123; if (!h[p]) &#123; o[p] = b.prototype[p]; &#125; &#125; b.apply(d, a);&#125; 这里的base就是继承函数了。继承函数的原理莫过于复制类的方法和属性。因此，只要做到这点，就可以实现类的继承了。可以在上面的代码中看见，我们通过遍历prototype来获取原型链中定义的方法和属性。通过apply调用父类的构造器进行构造器中属性和方法的复制。使用示例：123456789101112131415function People () &#123; this.name = \"Yorhom\";&#125;People.prototype.getName = function () &#123; return this.name;&#125;;function Student () &#123; base(this, People, []);&#125;var yorhom = new Student();// \"Yorhom\"alert(yorhom.getName()); 静态属性和方法的定义静态属性和方法以及静态类在js中的定义非常简单，先来看静态类：1var StaticClass = &#123;&#125;; 这么写不是在定义一个Object吗？是的，不错，不过js中的静态类也是可以这样定义的。如果要添加静态类中的方法和属性，就可以这么写：123456var StaticClass = &#123; id : 5, sayHello : function () &#123; alert(\"Hello\"); &#125;&#125;; 如果是要向类中添加静态属性或者方法，可以采用这种写法：123456789101112function People () &#123; this.name = \"Yorhom\";&#125;People.prototype.getName = function () &#123; return this.name;&#125;;People.TYPE = \"people\";People.sayHello = function () &#123; alert(\"Hello\");&#125;; 实现一个功能丰富的类我们在上文中提到了，节省内存和定义私有属性两者无法兼得，是啊，和“鱼和熊掌不可兼得”是一个道理，在通常的使用过程中，我们需要对这两项进行取舍。但是现在这个年代，哪有不可兼得的呢？鱼和熊掌不能同时吃？当然不行……因为吃熊掌是违法的（有待考证）？不过至少鸡和鱼是可以同时吃的吧。由于js没有实现私有属性的定义，所以这其实是一个没有头绪的工作，因为在标准的做法中，我们除了闭包可以阻止外部访问，没有别的办法了。所以这里我们要用点歪门邪道的方法了。 JavaScript Set/Get访问器什么是set/get访问器呢？如果你熟悉python，那么你可以理解为@property和@xxx.setter，难道简陋的js里也有？当然有，只不过是ES5的标准，可以采用这种写法：123456789Object.defineProperty(this, \"name\", &#123; get : funtion () &#123; return name; &#125;, set : function (v) &#123; name = v; &#125;&#125;); 具体有什么用呢？大致就是this.name属性在被获取的时候调用get访问器，在被更改值的时候调用set。你可以从上面的代码了解大致的写法，不过如果你想深究，可以参考这篇文章：http://blog.csdn.net/teajs/article/details/22738851 注意以上的这种用法会有兼容性问题，浏览器支持情况如下： PC端 Firefox Google Chrome Internet Explorer Opera Safari 4.0 5 9 11.6 5.1 移动端 Firefox Mobile Android IE Mobile Opera Mobile Safari Mobile 4.0 Yes 9 11.5 Yes 来自： https://developer.mozilla.org/…/defineProperty#Browser_compatibility 如何“歪门邪道”地做到禁止访问私有和保护属性？这是个比较头疼的问题，正如本节开篇所说，我们在常规开发下，只能通过闭包来阻止某变量的访问。可是如果你使用了prototype，那么闭包这条路就走不通了。在这种情况下，我们的Object.defineProperty就出场了。我们知道，通过这个函数可以设定获取属性时返回的值，也可以设定更改属性时设置的值。有了这个函数，我们可以随时跟踪到某个属性是不是在被获取，或者是不是在被更改。我们还需要一个开关，我们在类内部的方法调用时，把这个开关打开，表明是在内部运行，方法调用结束后将开关关闭，表明回到外部运行状态。有了这两个状态，我们就可以跟踪private和protected属性和方法了，一旦他们在开关关闭的时候被使用，就终止这个属性或方法的获取或设置。于是乎，大难题就快解决了。 开源库件jpp.js秉着这个歪门邪道的思想，我把这个功能封装到jpp.js这个库件中，库件的github地址如下：https://github.com/yuehaowang/jpp.js当然这个库件不限于创建一个类，还可以实现函数的重载等。目前库件还处于开发阶段，欢迎各位提交建议。 使用jpp.js创建一个类12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273var People = jpp.class(&#123; extends : null, private : &#123; id : null, hobby : null &#125;, protected : &#123; money : null, phoneNumber : null &#125;, public : &#123; firstName : null, lastName : null, age : null, birthday : null, occupation : null, constructor : function (name, id) &#123; if (name) &#123; var nameArray = name.split(\" \"); this.firstName = nameArray[0]; this.lastName = nameArray[1]; &#125; if (id) &#123; this.id = id; &#125; &#125;, setBirthday : function (date) &#123; if (date) &#123; this.birthday = date; &#125; &#125;, getBirthday : function () &#123; return this.birthday; &#125;, askForId : function () &#123; return this.id; &#125;, findHobby : function () &#123; return this.hobby; &#125; &#125;, static : &#123; OCCUPATION_PROGRAMMER : \"programmer\", OCCUPATION_ARTIST : \"artist\", OCCUPATION_MUSICIAN : \"musician\", OCCUPATION_STUDENT : \"student\" &#125;&#125;);var peter = new People(\"Peter Wong\", 543232123565);peter.occupation = People.OCCUPATION_PROGRAMMER;peter.setBirthday(\"19980727\");// result: Peteralert(peter.firstName);// result: 19990727alert(peter.getBirthday());// result: 51092028alert(peter.askForId());// result: nullalert(peter.findHobby());// result: programmeralert(peter.occupation);// erroralert(peter.id); 对上面的代码进行分析：使用jpp.class函数创建一个类，函数的参数是一个Object，这个Object可添加的属性如下： extends 继承时的父类 private 装载私有属性，里面定义的成员外部不可使用且不能继承给子类 protected 装载保护属性，里面定义的成员外部不可使用但可以继承给子类 public 装载公有属性 static 装载静态方法和属性 在创建类的过程中，在public中添加constructor方法初始化构造器，this.super可访问父类构造器。 运行代码，可以看到浏览器正常运行前5个alert，而最后一个运行的时候浏览器报错： 具体的实现过程有点复杂，不过原理在上文已经详细讲述了。代码可以在github里参看，欢迎各位研究。","categories":[{"name":"HTML5&JavaScript","slug":"HTML5-JavaScript","permalink":"http://yuehaowang.github.io/categories/HTML5-JavaScript/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yuehaowang.github.io/tags/JavaScript/"}]},{"title":"Hello World","slug":"hello-world","date":"2016-02-03T16:00:00.000Z","updated":"2016-08-05T15:39:04.000Z","comments":true,"path":"2016/02/04/hello-world/","link":"","permalink":"http://yuehaowang.github.io/2016/02/04/hello-world/","excerpt":"今天是2016年2月4日，我的独立博客建立了，欢迎各位关注～ 本博客使用Hexo构建，感谢PPOffice同学提供博客主题。 希望以后能写出更多，更好的博文～ 分享学习和生活中的精彩！","text":"今天是2016年2月4日，我的独立博客建立了，欢迎各位关注～ 本博客使用Hexo构建，感谢PPOffice同学提供博客主题。 希望以后能写出更多，更好的博文～ 分享学习和生活中的精彩！","categories":[{"name":"其他","slug":"其他","permalink":"http://yuehaowang.github.io/categories/其他/"}],"tags":[{"name":"其他","slug":"其他","permalink":"http://yuehaowang.github.io/tags/其他/"}]}]}